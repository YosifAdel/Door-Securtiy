
MC2_CONTROL_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002332  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011c  00800060  00002332  000023c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  0080017c  0080017c  000024e2  2**0
                  ALLOC
  3 .stab         00002358  00000000  00000000  000024e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000022f2  00000000  00000000  0000483c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00006b2e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  00006cce  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  00006ec0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  000092cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  0000a651  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  0000b828  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0000b9e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  0000bcde  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000c64c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1e 0e 	jmp	0x1c3c	; 0x1c3c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e3       	ldi	r30, 0x32	; 50
      68:	f3 e2       	ldi	r31, 0x23	; 35
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 37       	cpi	r26, 0x7C	; 124
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	ac e7       	ldi	r26, 0x7C	; 124
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 38       	cpi	r26, 0x80	; 128
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 17 07 	call	0xe2e	; 0xe2e <main>
      8a:	0c 94 97 11 	jmp	0x232e	; 0x232e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 60 11 	jmp	0x22c0	; 0x22c0 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 7c 11 	jmp	0x22f8	; 0x22f8 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 6c 11 	jmp	0x22d8	; 0x22d8 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 88 11 	jmp	0x2310	; 0x2310 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 6c 11 	jmp	0x22d8	; 0x22d8 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 88 11 	jmp	0x2310	; 0x2310 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 60 11 	jmp	0x22c0	; 0x22c0 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	80 e6       	ldi	r24, 0x60	; 96
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 7c 11 	jmp	0x22f8	; 0x22f8 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 68 11 	jmp	0x22d0	; 0x22d0 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	60 e6       	ldi	r22, 0x60	; 96
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 84 11 	jmp	0x2308	; 0x2308 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 6c 11 	jmp	0x22d8	; 0x22d8 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 88 11 	jmp	0x2310	; 0x2310 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 6c 11 	jmp	0x22d8	; 0x22d8 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 88 11 	jmp	0x2310	; 0x2310 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 6c 11 	jmp	0x22d8	; 0x22d8 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 88 11 	jmp	0x2310	; 0x2310 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 70 11 	jmp	0x22e0	; 0x22e0 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 8c 11 	jmp	0x2318	; 0x2318 <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 68 11 	jmp	0x22d0	; 0x22d0 <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 84 11 	jmp	0x2308	; 0x2308 <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	e8 59       	subi	r30, 0x98	; 152
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <main>:
void responseProcesses(void);
/*******************************************************************************/

/* Application Code */
int main(void)
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
     e36:	2a 97       	sbiw	r28, 0x0a	; 10
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
	/*Enable I-bit = 1*/
	S_REG.Bits.I_Bit = 1;
     e42:	ef e5       	ldi	r30, 0x5F	; 95
     e44:	f0 e0       	ldi	r31, 0x00	; 0
     e46:	80 81       	ld	r24, Z
     e48:	80 68       	ori	r24, 0x80	; 128
     e4a:	80 83       	st	Z, r24


	/*set the configurations of the I2C and pass it to the structure*/
	TWI_ConfigType	TWI_Configurations =
	{0x01,BR_400K};
     e4c:	ce 01       	movw	r24, r28
     e4e:	01 96       	adiw	r24, 0x01	; 1
     e50:	9f 83       	std	Y+7, r25	; 0x07
     e52:	8e 83       	std	Y+6, r24	; 0x06
     e54:	e7 e7       	ldi	r30, 0x77	; 119
     e56:	f1 e0       	ldi	r31, 0x01	; 1
     e58:	f9 87       	std	Y+9, r31	; 0x09
     e5a:	e8 87       	std	Y+8, r30	; 0x08
     e5c:	f5 e0       	ldi	r31, 0x05	; 5
     e5e:	fa 87       	std	Y+10, r31	; 0x0a
     e60:	e8 85       	ldd	r30, Y+8	; 0x08
     e62:	f9 85       	ldd	r31, Y+9	; 0x09
     e64:	00 80       	ld	r0, Z
     e66:	88 85       	ldd	r24, Y+8	; 0x08
     e68:	99 85       	ldd	r25, Y+9	; 0x09
     e6a:	01 96       	adiw	r24, 0x01	; 1
     e6c:	99 87       	std	Y+9, r25	; 0x09
     e6e:	88 87       	std	Y+8, r24	; 0x08
     e70:	ee 81       	ldd	r30, Y+6	; 0x06
     e72:	ff 81       	ldd	r31, Y+7	; 0x07
     e74:	00 82       	st	Z, r0
     e76:	8e 81       	ldd	r24, Y+6	; 0x06
     e78:	9f 81       	ldd	r25, Y+7	; 0x07
     e7a:	01 96       	adiw	r24, 0x01	; 1
     e7c:	9f 83       	std	Y+7, r25	; 0x07
     e7e:	8e 83       	std	Y+6, r24	; 0x06
     e80:	9a 85       	ldd	r25, Y+10	; 0x0a
     e82:	91 50       	subi	r25, 0x01	; 1
     e84:	9a 87       	std	Y+10, r25	; 0x0a
     e86:	ea 85       	ldd	r30, Y+10	; 0x0a
     e88:	ee 23       	and	r30, r30
     e8a:	51 f7       	brne	.-44     	; 0xe60 <main+0x32>

	/*initiate UART driver*/
	UART_init(&UART_Configurations);
     e8c:	88 e6       	ldi	r24, 0x68	; 104
     e8e:	91 e0       	ldi	r25, 0x01	; 1
     e90:	0e 94 af 0f 	call	0x1f5e	; 0x1f5e <UART_init>

	/*initiate I2C driver*/
	TWI_init(&TWI_Configurations);
     e94:	ce 01       	movw	r24, r28
     e96:	01 96       	adiw	r24, 0x01	; 1
     e98:	0e 94 0c 0f 	call	0x1e18	; 0x1e18 <TWI_init>

	/* initialize timer 1 driver*/
	Timer1_init(&Timer1_Configuration);
     e9c:	81 e7       	ldi	r24, 0x71	; 113
     e9e:	91 e0       	ldi	r25, 0x01	; 1
     ea0:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <Timer1_init>
	/* set the call back to pointer in the Timer 1 */
	Timer1_setCallBack(Timer_callBack);
     ea4:	8d e9       	ldi	r24, 0x9D	; 157
     ea6:	97 e0       	ldi	r25, 0x07	; 7
     ea8:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <Timer1_setCallBack>

	/*initiate Buzzer driver*/
	Buzzer_init();
     eac:	0e 94 79 09 	call	0x12f2	; 0x12f2 <Buzzer_init>

	/*initiate DC_motor driver*/
	DcMotor_init();
     eb0:	0e 94 a2 09 	call	0x1344	; 0x1344 <DcMotor_init>

	/* wait until MC2 receive that MC1 is ready*/
	while(UART_recieveByte()!=MC1_READY);
     eb4:	0e 94 af 10 	call	0x215e	; 0x215e <UART_recieveByte>
     eb8:	81 30       	cpi	r24, 0x01	; 1
     eba:	e1 f7       	brne	.-8      	; 0xeb4 <main+0x86>

	/* receive the password to be inserted in the EEPROM*/
	receive_password();
     ebc:	0e 94 ad 07 	call	0xf5a	; 0xf5a <receive_password>

	while(1)
	{

		/* store the state of the received byte */
		g_responseByte = UART_recieveByte();
     ec0:	0e 94 af 10 	call	0x215e	; 0x215e <UART_recieveByte>
     ec4:	80 93 7f 01 	sts	0x017F, r24

		/* check the state of response and do each task depends on the response */
		responseProcesses();
     ec8:	0e 94 67 07 	call	0xece	; 0xece <responseProcesses>
     ecc:	f9 cf       	rjmp	.-14     	; 0xec0 <main+0x92>

00000ece <responseProcesses>:

/*Description:
 * check the state of response and do each task depends on the response
 * */
void responseProcesses(void)
{
     ece:	df 93       	push	r29
     ed0:	cf 93       	push	r28
     ed2:	00 d0       	rcall	.+0      	; 0xed4 <responseProcesses+0x6>
     ed4:	cd b7       	in	r28, 0x3d	; 61
     ed6:	de b7       	in	r29, 0x3e	; 62
	switch(g_responseByte)
     ed8:	80 91 7f 01 	lds	r24, 0x017F
     edc:	28 2f       	mov	r18, r24
     ede:	30 e0       	ldi	r19, 0x00	; 0
     ee0:	3a 83       	std	Y+2, r19	; 0x02
     ee2:	29 83       	std	Y+1, r18	; 0x01
     ee4:	89 81       	ldd	r24, Y+1	; 0x01
     ee6:	9a 81       	ldd	r25, Y+2	; 0x02
     ee8:	81 31       	cpi	r24, 0x11	; 17
     eea:	91 05       	cpc	r25, r1
     eec:	e1 f0       	breq	.+56     	; 0xf26 <responseProcesses+0x58>
     eee:	29 81       	ldd	r18, Y+1	; 0x01
     ef0:	3a 81       	ldd	r19, Y+2	; 0x02
     ef2:	22 31       	cpi	r18, 0x12	; 18
     ef4:	31 05       	cpc	r19, r1
     ef6:	34 f4       	brge	.+12     	; 0xf04 <responseProcesses+0x36>
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
     efa:	9a 81       	ldd	r25, Y+2	; 0x02
     efc:	86 30       	cpi	r24, 0x06	; 6
     efe:	91 05       	cpc	r25, r1
     f00:	61 f0       	breq	.+24     	; 0xf1a <responseProcesses+0x4c>
     f02:	16 c0       	rjmp	.+44     	; 0xf30 <responseProcesses+0x62>
     f04:	29 81       	ldd	r18, Y+1	; 0x01
     f06:	3a 81       	ldd	r19, Y+2	; 0x02
     f08:	22 31       	cpi	r18, 0x12	; 18
     f0a:	31 05       	cpc	r19, r1
     f0c:	49 f0       	breq	.+18     	; 0xf20 <responseProcesses+0x52>
     f0e:	89 81       	ldd	r24, Y+1	; 0x01
     f10:	9a 81       	ldd	r25, Y+2	; 0x02
     f12:	83 31       	cpi	r24, 0x13	; 19
     f14:	91 05       	cpc	r25, r1
     f16:	51 f0       	breq	.+20     	; 0xf2c <responseProcesses+0x5e>
     f18:	0b c0       	rjmp	.+22     	; 0xf30 <responseProcesses+0x62>
	{
	/* this means that the password has been sent*/
	case SEND_PASSWORD_TO_BE_CHECKED:
		/* check whether its correct or not*/
		checkThePasswordAfterBeingStored();
     f1a:	0e 94 50 08 	call	0x10a0	; 0x10a0 <checkThePasswordAfterBeingStored>
     f1e:	08 c0       	rjmp	.+16     	; 0xf30 <responseProcesses+0x62>
		break;

	/* this means that the password is correct and request to open the door*/
	case UNLOCK_THE_DOOR:
		/* Door sequence [motor]*/
		motorSequence();
     f20:	0e 94 29 09 	call	0x1252	; 0x1252 <motorSequence>
     f24:	05 c0       	rjmp	.+10     	; 0xf30 <responseProcesses+0x62>
		break;

	/* this means that the password is wrong 3 times and the buzzer opened*/
	case BUZZER_ON_BYTE:
		/* Open the Buzzer for specific time */
		buzzer_IS_OPENED();
     f26:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <buzzer_IS_OPENED>
     f2a:	02 c0       	rjmp	.+4      	; 0xf30 <responseProcesses+0x62>
		break;
	case CHANGE_PASSWORD:
		/*Change the password sequence*/
		receive_password();
     f2c:	0e 94 ad 07 	call	0xf5a	; 0xf5a <receive_password>
		break;
	}
}
     f30:	0f 90       	pop	r0
     f32:	0f 90       	pop	r0
     f34:	cf 91       	pop	r28
     f36:	df 91       	pop	r29
     f38:	08 95       	ret

00000f3a <Timer_callBack>:

/* Description:
 * 	used to set the required time in each task.
 */
void Timer_callBack(void)
{
     f3a:	df 93       	push	r29
     f3c:	cf 93       	push	r28
     f3e:	cd b7       	in	r28, 0x3d	; 61
     f40:	de b7       	in	r29, 0x3e	; 62
	g_tick++;
     f42:	80 91 7c 01 	lds	r24, 0x017C
     f46:	8f 5f       	subi	r24, 0xFF	; 255
     f48:	80 93 7c 01 	sts	0x017C, r24
	/* clear the register*/
	TCNT1_REG.TwoBytes = 0;
     f4c:	ec e4       	ldi	r30, 0x4C	; 76
     f4e:	f0 e0       	ldi	r31, 0x00	; 0
     f50:	11 82       	std	Z+1, r1	; 0x01
     f52:	10 82       	st	Z, r1
}
     f54:	cf 91       	pop	r28
     f56:	df 91       	pop	r29
     f58:	08 95       	ret

00000f5a <receive_password>:

/* Description:
 * 	function to save the password in the EEPROM memory.
 */
void receive_password(void)
{
     f5a:	df 93       	push	r29
     f5c:	cf 93       	push	r28
     f5e:	cd b7       	in	r28, 0x3d	; 61
     f60:	de b7       	in	r29, 0x3e	; 62
     f62:	60 97       	sbiw	r28, 0x10	; 16
     f64:	0f b6       	in	r0, 0x3f	; 63
     f66:	f8 94       	cli
     f68:	de bf       	out	0x3e, r29	; 62
     f6a:	0f be       	out	0x3f, r0	; 63
     f6c:	cd bf       	out	0x3d, r28	; 61

	/* variable to count from 0 to password size*/
	uint8 passCounter;

	/* waits until the MC1 send the password to be stored at EEPROM*/
	while(UART_recieveByte() != SAVE_PASSWORD);
     f6e:	0e 94 af 10 	call	0x215e	; 0x215e <UART_recieveByte>
     f72:	84 30       	cpi	r24, 0x04	; 4
     f74:	e1 f7       	brne	.-8      	; 0xf6e <receive_password+0x14>

	/* loop to receive the password byte by byte*/
	for(passCounter = 0; passCounter<PASSWORD_SIZE;passCounter++)
     f76:	1f 86       	std	Y+15, r1	; 0x0f
     f78:	83 c0       	rjmp	.+262    	; 0x1080 <receive_password+0x126>
	{
		/*send byte to till the MC1 that MC2 is ready to receive the password*/
		UART_sendByte(MC2_READY);
     f7a:	82 e0       	ldi	r24, 0x02	; 2
     f7c:	0e 94 85 10 	call	0x210a	; 0x210a <UART_sendByte>

		/* receive each byte using this loop in pass variable*/
		pass = UART_recieveByte();
     f80:	0e 94 af 10 	call	0x215e	; 0x215e <UART_recieveByte>
     f84:	88 8b       	std	Y+16, r24	; 0x10

		/*after receive the byte in pass write it in the EEPROM*/
		EEPROM_writeByte((BEGGINING_OF_EEPROM_ADDRESS+passCounter) , pass);
     f86:	8f 85       	ldd	r24, Y+15	; 0x0f
     f88:	88 2f       	mov	r24, r24
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	80 59       	subi	r24, 0x90	; 144
     f8e:	9f 4f       	sbci	r25, 0xFF	; 255
     f90:	68 89       	ldd	r22, Y+16	; 0x10
     f92:	0e 94 02 0a 	call	0x1404	; 0x1404 <EEPROM_writeByte>
     f96:	80 e0       	ldi	r24, 0x00	; 0
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	a0 e2       	ldi	r26, 0x20	; 32
     f9c:	b1 e4       	ldi	r27, 0x41	; 65
     f9e:	8b 87       	std	Y+11, r24	; 0x0b
     fa0:	9c 87       	std	Y+12, r25	; 0x0c
     fa2:	ad 87       	std	Y+13, r26	; 0x0d
     fa4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     fa6:	6b 85       	ldd	r22, Y+11	; 0x0b
     fa8:	7c 85       	ldd	r23, Y+12	; 0x0c
     faa:	8d 85       	ldd	r24, Y+13	; 0x0d
     fac:	9e 85       	ldd	r25, Y+14	; 0x0e
     fae:	20 e0       	ldi	r18, 0x00	; 0
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	4a ef       	ldi	r20, 0xFA	; 250
     fb4:	54 e4       	ldi	r21, 0x44	; 68
     fb6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     fba:	dc 01       	movw	r26, r24
     fbc:	cb 01       	movw	r24, r22
     fbe:	8f 83       	std	Y+7, r24	; 0x07
     fc0:	98 87       	std	Y+8, r25	; 0x08
     fc2:	a9 87       	std	Y+9, r26	; 0x09
     fc4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     fc6:	6f 81       	ldd	r22, Y+7	; 0x07
     fc8:	78 85       	ldd	r23, Y+8	; 0x08
     fca:	89 85       	ldd	r24, Y+9	; 0x09
     fcc:	9a 85       	ldd	r25, Y+10	; 0x0a
     fce:	20 e0       	ldi	r18, 0x00	; 0
     fd0:	30 e0       	ldi	r19, 0x00	; 0
     fd2:	40 e8       	ldi	r20, 0x80	; 128
     fd4:	5f e3       	ldi	r21, 0x3F	; 63
     fd6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
     fda:	88 23       	and	r24, r24
     fdc:	2c f4       	brge	.+10     	; 0xfe8 <receive_password+0x8e>
		__ticks = 1;
     fde:	81 e0       	ldi	r24, 0x01	; 1
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	9e 83       	std	Y+6, r25	; 0x06
     fe4:	8d 83       	std	Y+5, r24	; 0x05
     fe6:	3f c0       	rjmp	.+126    	; 0x1066 <receive_password+0x10c>
	else if (__tmp > 65535)
     fe8:	6f 81       	ldd	r22, Y+7	; 0x07
     fea:	78 85       	ldd	r23, Y+8	; 0x08
     fec:	89 85       	ldd	r24, Y+9	; 0x09
     fee:	9a 85       	ldd	r25, Y+10	; 0x0a
     ff0:	20 e0       	ldi	r18, 0x00	; 0
     ff2:	3f ef       	ldi	r19, 0xFF	; 255
     ff4:	4f e7       	ldi	r20, 0x7F	; 127
     ff6:	57 e4       	ldi	r21, 0x47	; 71
     ff8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
     ffc:	18 16       	cp	r1, r24
     ffe:	4c f5       	brge	.+82     	; 0x1052 <receive_password+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1000:	6b 85       	ldd	r22, Y+11	; 0x0b
    1002:	7c 85       	ldd	r23, Y+12	; 0x0c
    1004:	8d 85       	ldd	r24, Y+13	; 0x0d
    1006:	9e 85       	ldd	r25, Y+14	; 0x0e
    1008:	20 e0       	ldi	r18, 0x00	; 0
    100a:	30 e0       	ldi	r19, 0x00	; 0
    100c:	40 e2       	ldi	r20, 0x20	; 32
    100e:	51 e4       	ldi	r21, 0x41	; 65
    1010:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1014:	dc 01       	movw	r26, r24
    1016:	cb 01       	movw	r24, r22
    1018:	bc 01       	movw	r22, r24
    101a:	cd 01       	movw	r24, r26
    101c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1020:	dc 01       	movw	r26, r24
    1022:	cb 01       	movw	r24, r22
    1024:	9e 83       	std	Y+6, r25	; 0x06
    1026:	8d 83       	std	Y+5, r24	; 0x05
    1028:	0f c0       	rjmp	.+30     	; 0x1048 <receive_password+0xee>
    102a:	88 ec       	ldi	r24, 0xC8	; 200
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	9c 83       	std	Y+4, r25	; 0x04
    1030:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1032:	8b 81       	ldd	r24, Y+3	; 0x03
    1034:	9c 81       	ldd	r25, Y+4	; 0x04
    1036:	01 97       	sbiw	r24, 0x01	; 1
    1038:	f1 f7       	brne	.-4      	; 0x1036 <receive_password+0xdc>
    103a:	9c 83       	std	Y+4, r25	; 0x04
    103c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    103e:	8d 81       	ldd	r24, Y+5	; 0x05
    1040:	9e 81       	ldd	r25, Y+6	; 0x06
    1042:	01 97       	sbiw	r24, 0x01	; 1
    1044:	9e 83       	std	Y+6, r25	; 0x06
    1046:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1048:	8d 81       	ldd	r24, Y+5	; 0x05
    104a:	9e 81       	ldd	r25, Y+6	; 0x06
    104c:	00 97       	sbiw	r24, 0x00	; 0
    104e:	69 f7       	brne	.-38     	; 0x102a <receive_password+0xd0>
    1050:	14 c0       	rjmp	.+40     	; 0x107a <receive_password+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1052:	6f 81       	ldd	r22, Y+7	; 0x07
    1054:	78 85       	ldd	r23, Y+8	; 0x08
    1056:	89 85       	ldd	r24, Y+9	; 0x09
    1058:	9a 85       	ldd	r25, Y+10	; 0x0a
    105a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    105e:	dc 01       	movw	r26, r24
    1060:	cb 01       	movw	r24, r22
    1062:	9e 83       	std	Y+6, r25	; 0x06
    1064:	8d 83       	std	Y+5, r24	; 0x05
    1066:	8d 81       	ldd	r24, Y+5	; 0x05
    1068:	9e 81       	ldd	r25, Y+6	; 0x06
    106a:	9a 83       	std	Y+2, r25	; 0x02
    106c:	89 83       	std	Y+1, r24	; 0x01
    106e:	89 81       	ldd	r24, Y+1	; 0x01
    1070:	9a 81       	ldd	r25, Y+2	; 0x02
    1072:	01 97       	sbiw	r24, 0x01	; 1
    1074:	f1 f7       	brne	.-4      	; 0x1072 <receive_password+0x118>
    1076:	9a 83       	std	Y+2, r25	; 0x02
    1078:	89 83       	std	Y+1, r24	; 0x01

	/* waits until the MC1 send the password to be stored at EEPROM*/
	while(UART_recieveByte() != SAVE_PASSWORD);

	/* loop to receive the password byte by byte*/
	for(passCounter = 0; passCounter<PASSWORD_SIZE;passCounter++)
    107a:	8f 85       	ldd	r24, Y+15	; 0x0f
    107c:	8f 5f       	subi	r24, 0xFF	; 255
    107e:	8f 87       	std	Y+15, r24	; 0x0f
    1080:	8f 85       	ldd	r24, Y+15	; 0x0f
    1082:	85 30       	cpi	r24, 0x05	; 5
    1084:	08 f4       	brcc	.+2      	; 0x1088 <receive_password+0x12e>
    1086:	79 cf       	rjmp	.-270    	; 0xf7a <receive_password+0x20>
		_delay_ms(10);
	}

	/* after the loop this means that the password has been stored in the EEPROM*/
	/* send byte to MC1 to tell him that the password has been saved*/
	UART_sendByte(PASSWORD_SAVED);
    1088:	85 e0       	ldi	r24, 0x05	; 5
    108a:	0e 94 85 10 	call	0x210a	; 0x210a <UART_sendByte>
}
    108e:	60 96       	adiw	r28, 0x10	; 16
    1090:	0f b6       	in	r0, 0x3f	; 63
    1092:	f8 94       	cli
    1094:	de bf       	out	0x3e, r29	; 62
    1096:	0f be       	out	0x3f, r0	; 63
    1098:	cd bf       	out	0x3d, r28	; 61
    109a:	cf 91       	pop	r28
    109c:	df 91       	pop	r29
    109e:	08 95       	ret

000010a0 <checkThePasswordAfterBeingStored>:

/* Description:
 * 	function to read the password from the EEPROM memory and check whether correct or wrong.
 */
void checkThePasswordAfterBeingStored(void)
{
    10a0:	0f 93       	push	r16
    10a2:	1f 93       	push	r17
    10a4:	df 93       	push	r29
    10a6:	cf 93       	push	r28
    10a8:	cd b7       	in	r28, 0x3d	; 61
    10aa:	de b7       	in	r29, 0x3e	; 62
    10ac:	6a 97       	sbiw	r28, 0x1a	; 26
    10ae:	0f b6       	in	r0, 0x3f	; 63
    10b0:	f8 94       	cli
    10b2:	de bf       	out	0x3e, r29	; 62
    10b4:	0f be       	out	0x3f, r0	; 63
    10b6:	cd bf       	out	0x3d, r28	; 61
	/* variable to count from 0 to password size*/
	uint8 passCounter;

	uint8 wrong_times = 0;	/* variable to store the wrong times that password have been submitted*/
    10b8:	1f 86       	std	Y+15, r1	; 0x0f

	/* array of the saved password [correct password]*/
	uint8 saved_pass[PASSWORD_SIZE];

	/* waits until MC1 send the password and MC2 received to be checked*/
	while(UART_recieveByte() != PASSWORD_CHECK);
    10ba:	0e 94 af 10 	call	0x215e	; 0x215e <UART_recieveByte>
    10be:	82 31       	cpi	r24, 0x12	; 18
    10c0:	e1 f7       	brne	.-8      	; 0x10ba <checkThePasswordAfterBeingStored+0x1a>

	passCounter = 0;
    10c2:	18 8a       	std	Y+16, r1	; 0x10
    10c4:	b7 c0       	rjmp	.+366    	; 0x1234 <checkThePasswordAfterBeingStored+0x194>
	/* check if the two arrays of password are identical or not*/
	while(passCounter < PASSWORD_SIZE)
	{
		/*send byte to till the MC1 that MC2*/
		UART_sendByte(MC2_READY);
    10c6:	82 e0       	ldi	r24, 0x02	; 2
    10c8:	0e 94 85 10 	call	0x210a	; 0x210a <UART_sendByte>

		/* receive each byte using this loop in pass variable*/
		entered_pass[passCounter] = UART_recieveByte();
    10cc:	88 89       	ldd	r24, Y+16	; 0x10
    10ce:	08 2f       	mov	r16, r24
    10d0:	10 e0       	ldi	r17, 0x00	; 0
    10d2:	0e 94 af 10 	call	0x215e	; 0x215e <UART_recieveByte>
    10d6:	28 2f       	mov	r18, r24
    10d8:	ce 01       	movw	r24, r28
    10da:	41 96       	adiw	r24, 0x11	; 17
    10dc:	fc 01       	movw	r30, r24
    10de:	e0 0f       	add	r30, r16
    10e0:	f1 1f       	adc	r31, r17
    10e2:	20 83       	st	Z, r18

		/*after receive the byte in pass write it in the EEPROM*/
		EEPROM_readByte((BEGGINING_OF_EEPROM_ADDRESS + passCounter) , &saved_pass[passCounter]);
    10e4:	88 89       	ldd	r24, Y+16	; 0x10
    10e6:	88 2f       	mov	r24, r24
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	80 59       	subi	r24, 0x90	; 144
    10ec:	9f 4f       	sbci	r25, 0xFF	; 255
    10ee:	ac 01       	movw	r20, r24
    10f0:	88 89       	ldd	r24, Y+16	; 0x10
    10f2:	88 2f       	mov	r24, r24
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	9e 01       	movw	r18, r28
    10f8:	2a 5e       	subi	r18, 0xEA	; 234
    10fa:	3f 4f       	sbci	r19, 0xFF	; 255
    10fc:	28 0f       	add	r18, r24
    10fe:	39 1f       	adc	r19, r25
    1100:	ca 01       	movw	r24, r20
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 43 0a 	call	0x1486	; 0x1486 <EEPROM_readByte>
    1108:	80 e0       	ldi	r24, 0x00	; 0
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	a0 e2       	ldi	r26, 0x20	; 32
    110e:	b1 e4       	ldi	r27, 0x41	; 65
    1110:	8b 87       	std	Y+11, r24	; 0x0b
    1112:	9c 87       	std	Y+12, r25	; 0x0c
    1114:	ad 87       	std	Y+13, r26	; 0x0d
    1116:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1118:	6b 85       	ldd	r22, Y+11	; 0x0b
    111a:	7c 85       	ldd	r23, Y+12	; 0x0c
    111c:	8d 85       	ldd	r24, Y+13	; 0x0d
    111e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1120:	20 e0       	ldi	r18, 0x00	; 0
    1122:	30 e0       	ldi	r19, 0x00	; 0
    1124:	4a ef       	ldi	r20, 0xFA	; 250
    1126:	54 e4       	ldi	r21, 0x44	; 68
    1128:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    112c:	dc 01       	movw	r26, r24
    112e:	cb 01       	movw	r24, r22
    1130:	8f 83       	std	Y+7, r24	; 0x07
    1132:	98 87       	std	Y+8, r25	; 0x08
    1134:	a9 87       	std	Y+9, r26	; 0x09
    1136:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1138:	6f 81       	ldd	r22, Y+7	; 0x07
    113a:	78 85       	ldd	r23, Y+8	; 0x08
    113c:	89 85       	ldd	r24, Y+9	; 0x09
    113e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1140:	20 e0       	ldi	r18, 0x00	; 0
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	40 e8       	ldi	r20, 0x80	; 128
    1146:	5f e3       	ldi	r21, 0x3F	; 63
    1148:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    114c:	88 23       	and	r24, r24
    114e:	2c f4       	brge	.+10     	; 0x115a <checkThePasswordAfterBeingStored+0xba>
		__ticks = 1;
    1150:	81 e0       	ldi	r24, 0x01	; 1
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	9e 83       	std	Y+6, r25	; 0x06
    1156:	8d 83       	std	Y+5, r24	; 0x05
    1158:	3f c0       	rjmp	.+126    	; 0x11d8 <checkThePasswordAfterBeingStored+0x138>
	else if (__tmp > 65535)
    115a:	6f 81       	ldd	r22, Y+7	; 0x07
    115c:	78 85       	ldd	r23, Y+8	; 0x08
    115e:	89 85       	ldd	r24, Y+9	; 0x09
    1160:	9a 85       	ldd	r25, Y+10	; 0x0a
    1162:	20 e0       	ldi	r18, 0x00	; 0
    1164:	3f ef       	ldi	r19, 0xFF	; 255
    1166:	4f e7       	ldi	r20, 0x7F	; 127
    1168:	57 e4       	ldi	r21, 0x47	; 71
    116a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    116e:	18 16       	cp	r1, r24
    1170:	4c f5       	brge	.+82     	; 0x11c4 <checkThePasswordAfterBeingStored+0x124>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1172:	6b 85       	ldd	r22, Y+11	; 0x0b
    1174:	7c 85       	ldd	r23, Y+12	; 0x0c
    1176:	8d 85       	ldd	r24, Y+13	; 0x0d
    1178:	9e 85       	ldd	r25, Y+14	; 0x0e
    117a:	20 e0       	ldi	r18, 0x00	; 0
    117c:	30 e0       	ldi	r19, 0x00	; 0
    117e:	40 e2       	ldi	r20, 0x20	; 32
    1180:	51 e4       	ldi	r21, 0x41	; 65
    1182:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1186:	dc 01       	movw	r26, r24
    1188:	cb 01       	movw	r24, r22
    118a:	bc 01       	movw	r22, r24
    118c:	cd 01       	movw	r24, r26
    118e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1192:	dc 01       	movw	r26, r24
    1194:	cb 01       	movw	r24, r22
    1196:	9e 83       	std	Y+6, r25	; 0x06
    1198:	8d 83       	std	Y+5, r24	; 0x05
    119a:	0f c0       	rjmp	.+30     	; 0x11ba <checkThePasswordAfterBeingStored+0x11a>
    119c:	88 ec       	ldi	r24, 0xC8	; 200
    119e:	90 e0       	ldi	r25, 0x00	; 0
    11a0:	9c 83       	std	Y+4, r25	; 0x04
    11a2:	8b 83       	std	Y+3, r24	; 0x03
    11a4:	8b 81       	ldd	r24, Y+3	; 0x03
    11a6:	9c 81       	ldd	r25, Y+4	; 0x04
    11a8:	01 97       	sbiw	r24, 0x01	; 1
    11aa:	f1 f7       	brne	.-4      	; 0x11a8 <checkThePasswordAfterBeingStored+0x108>
    11ac:	9c 83       	std	Y+4, r25	; 0x04
    11ae:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    11b0:	8d 81       	ldd	r24, Y+5	; 0x05
    11b2:	9e 81       	ldd	r25, Y+6	; 0x06
    11b4:	01 97       	sbiw	r24, 0x01	; 1
    11b6:	9e 83       	std	Y+6, r25	; 0x06
    11b8:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    11ba:	8d 81       	ldd	r24, Y+5	; 0x05
    11bc:	9e 81       	ldd	r25, Y+6	; 0x06
    11be:	00 97       	sbiw	r24, 0x00	; 0
    11c0:	69 f7       	brne	.-38     	; 0x119c <checkThePasswordAfterBeingStored+0xfc>
    11c2:	14 c0       	rjmp	.+40     	; 0x11ec <checkThePasswordAfterBeingStored+0x14c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    11c4:	6f 81       	ldd	r22, Y+7	; 0x07
    11c6:	78 85       	ldd	r23, Y+8	; 0x08
    11c8:	89 85       	ldd	r24, Y+9	; 0x09
    11ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    11cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    11d0:	dc 01       	movw	r26, r24
    11d2:	cb 01       	movw	r24, r22
    11d4:	9e 83       	std	Y+6, r25	; 0x06
    11d6:	8d 83       	std	Y+5, r24	; 0x05
    11d8:	8d 81       	ldd	r24, Y+5	; 0x05
    11da:	9e 81       	ldd	r25, Y+6	; 0x06
    11dc:	9a 83       	std	Y+2, r25	; 0x02
    11de:	89 83       	std	Y+1, r24	; 0x01
    11e0:	89 81       	ldd	r24, Y+1	; 0x01
    11e2:	9a 81       	ldd	r25, Y+2	; 0x02
    11e4:	01 97       	sbiw	r24, 0x01	; 1
    11e6:	f1 f7       	brne	.-4      	; 0x11e4 <checkThePasswordAfterBeingStored+0x144>
    11e8:	9a 83       	std	Y+2, r25	; 0x02
    11ea:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(10);

		/* if any character is different then both are not identical then it is not matched
		 * increase wrong times */
		if(entered_pass[passCounter] != saved_pass[passCounter])
    11ec:	88 89       	ldd	r24, Y+16	; 0x10
    11ee:	28 2f       	mov	r18, r24
    11f0:	30 e0       	ldi	r19, 0x00	; 0
    11f2:	ce 01       	movw	r24, r28
    11f4:	41 96       	adiw	r24, 0x11	; 17
    11f6:	fc 01       	movw	r30, r24
    11f8:	e2 0f       	add	r30, r18
    11fa:	f3 1f       	adc	r31, r19
    11fc:	40 81       	ld	r20, Z
    11fe:	88 89       	ldd	r24, Y+16	; 0x10
    1200:	28 2f       	mov	r18, r24
    1202:	30 e0       	ldi	r19, 0x00	; 0
    1204:	ce 01       	movw	r24, r28
    1206:	46 96       	adiw	r24, 0x16	; 22
    1208:	fc 01       	movw	r30, r24
    120a:	e2 0f       	add	r30, r18
    120c:	f3 1f       	adc	r31, r19
    120e:	80 81       	ld	r24, Z
    1210:	48 17       	cp	r20, r24
    1212:	19 f0       	breq	.+6      	; 0x121a <checkThePasswordAfterBeingStored+0x17a>
		{
			wrong_times ++;
    1214:	8f 85       	ldd	r24, Y+15	; 0x0f
    1216:	8f 5f       	subi	r24, 0xFF	; 255
    1218:	8f 87       	std	Y+15, r24	; 0x0f
		}

		if(wrong_times == 0)
    121a:	8f 85       	ldd	r24, Y+15	; 0x0f
    121c:	88 23       	and	r24, r24
    121e:	21 f4       	brne	.+8      	; 0x1228 <checkThePasswordAfterBeingStored+0x188>
		{
			/* This means the person entered the password Correct*/
			UART_sendByte(PASSWORD_MATCH);
    1220:	89 e0       	ldi	r24, 0x09	; 9
    1222:	0e 94 85 10 	call	0x210a	; 0x210a <UART_sendByte>
    1226:	03 c0       	rjmp	.+6      	; 0x122e <checkThePasswordAfterBeingStored+0x18e>
		}
		/* This means the person entered the password wrong*/
		else
		{
			UART_sendByte(PASSWORD_DOESNT_MATCH);
    1228:	88 e0       	ldi	r24, 0x08	; 8
    122a:	0e 94 85 10 	call	0x210a	; 0x210a <UART_sendByte>
		}
		passCounter++;
    122e:	88 89       	ldd	r24, Y+16	; 0x10
    1230:	8f 5f       	subi	r24, 0xFF	; 255
    1232:	88 8b       	std	Y+16, r24	; 0x10
	/* waits until MC1 send the password and MC2 received to be checked*/
	while(UART_recieveByte() != PASSWORD_CHECK);

	passCounter = 0;
	/* check if the two arrays of password are identical or not*/
	while(passCounter < PASSWORD_SIZE)
    1234:	88 89       	ldd	r24, Y+16	; 0x10
    1236:	85 30       	cpi	r24, 0x05	; 5
    1238:	08 f4       	brcc	.+2      	; 0x123c <checkThePasswordAfterBeingStored+0x19c>
    123a:	45 cf       	rjmp	.-374    	; 0x10c6 <checkThePasswordAfterBeingStored+0x26>
			UART_sendByte(PASSWORD_DOESNT_MATCH);
		}
		passCounter++;
	}

}
    123c:	6a 96       	adiw	r28, 0x1a	; 26
    123e:	0f b6       	in	r0, 0x3f	; 63
    1240:	f8 94       	cli
    1242:	de bf       	out	0x3e, r29	; 62
    1244:	0f be       	out	0x3f, r0	; 63
    1246:	cd bf       	out	0x3d, r28	; 61
    1248:	cf 91       	pop	r28
    124a:	df 91       	pop	r29
    124c:	1f 91       	pop	r17
    124e:	0f 91       	pop	r16
    1250:	08 95       	ret

00001252 <motorSequence>:

/* Description:
 * 	function to activate the motor and do its sequence [unlocking , open , locking, locked].
 */
void motorSequence(void)
{
    1252:	df 93       	push	r29
    1254:	cf 93       	push	r28
    1256:	cd b7       	in	r28, 0x3d	; 61
    1258:	de b7       	in	r29, 0x3e	; 62
	/* initialize timer 1 driver*/
	Timer1_init(&Timer1_Configuration);
    125a:	81 e7       	ldi	r24, 0x71	; 113
    125c:	91 e0       	ldi	r25, 0x01	; 1
    125e:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <Timer1_init>
	Timer1_setCallBack(Timer_callBack);
    1262:	8d e9       	ldi	r24, 0x9D	; 157
    1264:	97 e0       	ldi	r25, 0x07	; 7
    1266:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <Timer1_setCallBack>

	/* 1. Unlock the Door for specific time , so the motor will operate in CW*/
	DcMotor_Rotate(CW, DC_MOTOR_SPEED);
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	64 e6       	ldi	r22, 0x64	; 100
    126e:	0e 94 bd 09 	call	0x137a	; 0x137a <DcMotor_Rotate>
	/* initiate the time for this specific time*/
	/*set g_tick = 0 to clear it*/
	g_tick = 0;
    1272:	10 92 7c 01 	sts	0x017C, r1
	/* waits until the motor movement CW time be done then break the loop*/
	while (g_tick != MOTOR_CW_TIME) {} ;
    1276:	80 91 7c 01 	lds	r24, 0x017C
    127a:	8f 30       	cpi	r24, 0x0F	; 15
    127c:	e1 f7       	brne	.-8      	; 0x1276 <motorSequence+0x24>

	/* 2. Open the Door for specific time , so the motor will operate in CW*/
	DcMotor_Rotate(OFF, ZERO);
    127e:	80 e0       	ldi	r24, 0x00	; 0
    1280:	60 e0       	ldi	r22, 0x00	; 0
    1282:	0e 94 bd 09 	call	0x137a	; 0x137a <DcMotor_Rotate>
	/* initiate the time for this specific time*/
	/*set g_tick = 0 to clear it*/
	g_tick = 0;
    1286:	10 92 7c 01 	sts	0x017C, r1
	/* waits until the motor stop time be done then break the loop*/
	while (g_tick != MOTOR_STOP_TIME) {} ;
    128a:	80 91 7c 01 	lds	r24, 0x017C
    128e:	83 30       	cpi	r24, 0x03	; 3
    1290:	e1 f7       	brne	.-8      	; 0x128a <motorSequence+0x38>

	/* 3. Lock the Door for specific time , so the motor will operate in CW*/
	DcMotor_Rotate(ACW, DC_MOTOR_SPEED);
    1292:	82 e0       	ldi	r24, 0x02	; 2
    1294:	64 e6       	ldi	r22, 0x64	; 100
    1296:	0e 94 bd 09 	call	0x137a	; 0x137a <DcMotor_Rotate>

	/* initiate the time for this specific time*/
	/*set g_tick = 0 to clear it*/
	g_tick = 0;
    129a:	10 92 7c 01 	sts	0x017C, r1
	/* waits until the motor movement ACW be done then break the loop*/
	while (g_tick != MOTOR_ACW_TIME) {} ;
    129e:	80 91 7c 01 	lds	r24, 0x017C
    12a2:	8f 30       	cpi	r24, 0x0F	; 15
    12a4:	e1 f7       	brne	.-8      	; 0x129e <motorSequence+0x4c>


	/* 4. stop the motor and stop the timer*/
	DcMotor_Rotate(OFF,DC_MOTOR_SPEED);
    12a6:	80 e0       	ldi	r24, 0x00	; 0
    12a8:	64 e6       	ldi	r22, 0x64	; 100
    12aa:	0e 94 bd 09 	call	0x137a	; 0x137a <DcMotor_Rotate>
	/* stop the timer */
	Timer1_deInit();
    12ae:	0e 94 ed 0e 	call	0x1dda	; 0x1dda <Timer1_deInit>
}
    12b2:	cf 91       	pop	r28
    12b4:	df 91       	pop	r29
    12b6:	08 95       	ret

000012b8 <buzzer_IS_OPENED>:

/* Description:
 * 	function to activate the buzzer and do its sequence.
 */
void buzzer_IS_OPENED(void)
{
    12b8:	df 93       	push	r29
    12ba:	cf 93       	push	r28
    12bc:	cd b7       	in	r28, 0x3d	; 61
    12be:	de b7       	in	r29, 0x3e	; 62
	/* initialize timer 1 driver*/
	Timer1_init(&Timer1_Configuration);
    12c0:	81 e7       	ldi	r24, 0x71	; 113
    12c2:	91 e0       	ldi	r25, 0x01	; 1
    12c4:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <Timer1_init>
	Timer1_setCallBack(Timer_callBack);
    12c8:	8d e9       	ldi	r24, 0x9D	; 157
    12ca:	97 e0       	ldi	r25, 0x07	; 7
    12cc:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <Timer1_setCallBack>

	/*set g_tick = 0 to clear it*/
	g_tick = 0;
    12d0:	10 92 7c 01 	sts	0x017C, r1

	Buzzer_on();
    12d4:	0e 94 8a 09 	call	0x1314	; 0x1314 <Buzzer_on>
	/* waits until the door open time be done then break the loop*/
	while (g_tick != ERROR_TIME) {} ;
    12d8:	80 91 7c 01 	lds	r24, 0x017C
    12dc:	8c 33       	cpi	r24, 0x3C	; 60
    12de:	e1 f7       	brne	.-8      	; 0x12d8 <buzzer_IS_OPENED+0x20>

	/*after the error time finish , turn the buzzer OFF*/
	Buzzer_off();
    12e0:	0e 94 96 09 	call	0x132c	; 0x132c <Buzzer_off>

	/* stop the timer */
	Timer1_deInit();
    12e4:	0e 94 ed 0e 	call	0x1dda	; 0x1dda <Timer1_deInit>
	/*set g_tick = 0 to clear it*/
	g_tick = 0;
    12e8:	10 92 7c 01 	sts	0x017C, r1
}
    12ec:	cf 91       	pop	r28
    12ee:	df 91       	pop	r29
    12f0:	08 95       	ret

000012f2 <Buzzer_init>:
	 Turn off the buzzer through the GPIO.
 Inputs: None
 Return: None
*/
void Buzzer_init(void)
{
    12f2:	df 93       	push	r29
    12f4:	cf 93       	push	r28
    12f6:	cd b7       	in	r28, 0x3d	; 61
    12f8:	de b7       	in	r29, 0x3e	; 62
	/*Setup the direction for the buzzer pin as output pin*/
	GPIO_setupPinDirection(BUZZER_PORT_ID, BUZZER_PIN_ID, PIN_OUTPUT);
    12fa:	80 e0       	ldi	r24, 0x00	; 0
    12fc:	60 e0       	ldi	r22, 0x00	; 0
    12fe:	41 e0       	ldi	r20, 0x01	; 1
    1300:	0e 94 a3 0a 	call	0x1546	; 0x1546 <GPIO_setupPinDirection>

	/* Turn off the buzzer */
	GPIO_writePin(BUZZER_PORT_ID, BUZZER_PIN_ID, BUZZER_OFF);
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	60 e0       	ldi	r22, 0x00	; 0
    1308:	40 e0       	ldi	r20, 0x00	; 0
    130a:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
}
    130e:	cf 91       	pop	r28
    1310:	df 91       	pop	r29
    1312:	08 95       	ret

00001314 <Buzzer_on>:
	 Function to enable the Buzzer through the GPIO.
 Inputs: None
 Return: None
*/
void Buzzer_on(void)
{
    1314:	df 93       	push	r29
    1316:	cf 93       	push	r28
    1318:	cd b7       	in	r28, 0x3d	; 61
    131a:	de b7       	in	r29, 0x3e	; 62
	/* Turn ON the buzzer */
	GPIO_writePin(BUZZER_PORT_ID, BUZZER_PIN_ID, BUZZER_ON);
    131c:	80 e0       	ldi	r24, 0x00	; 0
    131e:	60 e0       	ldi	r22, 0x00	; 0
    1320:	41 e0       	ldi	r20, 0x01	; 1
    1322:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
}
    1326:	cf 91       	pop	r28
    1328:	df 91       	pop	r29
    132a:	08 95       	ret

0000132c <Buzzer_off>:
	 Function to disable the Buzzer through the GPIO.
 Inputs: None
 Return: No
*/
void Buzzer_off(void)
{
    132c:	df 93       	push	r29
    132e:	cf 93       	push	r28
    1330:	cd b7       	in	r28, 0x3d	; 61
    1332:	de b7       	in	r29, 0x3e	; 62
	/* Turn OFF the buzzer */
	GPIO_writePin(BUZZER_PORT_ID, BUZZER_PIN_ID, BUZZER_OFF);
    1334:	80 e0       	ldi	r24, 0x00	; 0
    1336:	60 e0       	ldi	r22, 0x00	; 0
    1338:	40 e0       	ldi	r20, 0x00	; 0
    133a:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
}
    133e:	cf 91       	pop	r28
    1340:	df 91       	pop	r29
    1342:	08 95       	ret

00001344 <DcMotor_init>:
/*
 * Description:
 * The Function responsible for setup the direction for the two motor pins through the GPIO driver.
   Stop at the DC-Motor at the beginning through the GPIO driver.*/
void DcMotor_init(void)
{
    1344:	df 93       	push	r29
    1346:	cf 93       	push	r28
    1348:	cd b7       	in	r28, 0x3d	; 61
    134a:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(DC_MOTOR_PORT_ID,DC_MOTOR_First_PIN_ID,PIN_OUTPUT);	/* PC0 Output Pin */
    134c:	81 e0       	ldi	r24, 0x01	; 1
    134e:	60 e0       	ldi	r22, 0x00	; 0
    1350:	41 e0       	ldi	r20, 0x01	; 1
    1352:	0e 94 a3 0a 	call	0x1546	; 0x1546 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(DC_MOTOR_PORT_ID,DC_MOTOR_Second_PIN_ID,PIN_OUTPUT);	/* PC1 Output Pin */
    1356:	81 e0       	ldi	r24, 0x01	; 1
    1358:	61 e0       	ldi	r22, 0x01	; 1
    135a:	41 e0       	ldi	r20, 0x01	; 1
    135c:	0e 94 a3 0a 	call	0x1546	; 0x1546 <GPIO_setupPinDirection>

	/* Turn off the motor */
	GPIO_writePin(DC_MOTOR_PORT_ID,DC_MOTOR_First_PIN_ID,LOGIC_LOW);
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	60 e0       	ldi	r22, 0x00	; 0
    1364:	40 e0       	ldi	r20, 0x00	; 0
    1366:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
	GPIO_writePin(DC_MOTOR_PORT_ID,DC_MOTOR_Second_PIN_ID,LOGIC_LOW);
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	61 e0       	ldi	r22, 0x01	; 1
    136e:	40 e0       	ldi	r20, 0x00	; 0
    1370:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
}
    1374:	cf 91       	pop	r28
    1376:	df 91       	pop	r29
    1378:	08 95       	ret

0000137a <DcMotor_Rotate>:
/*
 * The function responsible for rotate the DC Motor CW/ or A-CW or stop the motor based on the state input state value.
 * Send the required duty cycle to the PWM driver based on the required speed value.*/

void DcMotor_Rotate(DcMotor_State state,uint8 speed)
{
    137a:	df 93       	push	r29
    137c:	cf 93       	push	r28
    137e:	00 d0       	rcall	.+0      	; 0x1380 <DcMotor_Rotate+0x6>
    1380:	00 d0       	rcall	.+0      	; 0x1382 <DcMotor_Rotate+0x8>
    1382:	cd b7       	in	r28, 0x3d	; 61
    1384:	de b7       	in	r29, 0x3e	; 62
    1386:	89 83       	std	Y+1, r24	; 0x01
    1388:	6a 83       	std	Y+2, r22	; 0x02
	PWM_Timer0_Start(speed);
    138a:	8a 81       	ldd	r24, Y+2	; 0x02
    138c:	0e 94 d9 0d 	call	0x1bb2	; 0x1bb2 <PWM_Timer0_Start>
	switch(state)
    1390:	89 81       	ldd	r24, Y+1	; 0x01
    1392:	28 2f       	mov	r18, r24
    1394:	30 e0       	ldi	r19, 0x00	; 0
    1396:	3c 83       	std	Y+4, r19	; 0x04
    1398:	2b 83       	std	Y+3, r18	; 0x03
    139a:	8b 81       	ldd	r24, Y+3	; 0x03
    139c:	9c 81       	ldd	r25, Y+4	; 0x04
    139e:	81 30       	cpi	r24, 0x01	; 1
    13a0:	91 05       	cpc	r25, r1
    13a2:	a1 f0       	breq	.+40     	; 0x13cc <DcMotor_Rotate+0x52>
    13a4:	2b 81       	ldd	r18, Y+3	; 0x03
    13a6:	3c 81       	ldd	r19, Y+4	; 0x04
    13a8:	22 30       	cpi	r18, 0x02	; 2
    13aa:	31 05       	cpc	r19, r1
    13ac:	d1 f0       	breq	.+52     	; 0x13e2 <DcMotor_Rotate+0x68>
    13ae:	8b 81       	ldd	r24, Y+3	; 0x03
    13b0:	9c 81       	ldd	r25, Y+4	; 0x04
    13b2:	00 97       	sbiw	r24, 0x00	; 0
    13b4:	01 f5       	brne	.+64     	; 0x13f6 <DcMotor_Rotate+0x7c>
	{
	case OFF:
		/* Stop the motor */
		GPIO_writePin(DC_MOTOR_PORT_ID,DC_MOTOR_First_PIN_ID,LOGIC_LOW);
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	60 e0       	ldi	r22, 0x00	; 0
    13ba:	40 e0       	ldi	r20, 0x00	; 0
    13bc:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT_ID,DC_MOTOR_Second_PIN_ID,LOGIC_LOW);
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	61 e0       	ldi	r22, 0x01	; 1
    13c4:	40 e0       	ldi	r20, 0x00	; 0
    13c6:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
    13ca:	15 c0       	rjmp	.+42     	; 0x13f6 <DcMotor_Rotate+0x7c>
		break;
	case CW:
		/* Rotates the motor CW */
		GPIO_writePin(DC_MOTOR_PORT_ID,DC_MOTOR_First_PIN_ID,LOGIC_HIGH);
    13cc:	81 e0       	ldi	r24, 0x01	; 1
    13ce:	60 e0       	ldi	r22, 0x00	; 0
    13d0:	41 e0       	ldi	r20, 0x01	; 1
    13d2:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT_ID,DC_MOTOR_Second_PIN_ID,LOGIC_LOW);
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	61 e0       	ldi	r22, 0x01	; 1
    13da:	40 e0       	ldi	r20, 0x00	; 0
    13dc:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
    13e0:	0a c0       	rjmp	.+20     	; 0x13f6 <DcMotor_Rotate+0x7c>
		break;

	case ACW:
		/* Rotates the motor ACW */
		GPIO_writePin(DC_MOTOR_PORT_ID,DC_MOTOR_First_PIN_ID,LOGIC_LOW);
    13e2:	81 e0       	ldi	r24, 0x01	; 1
    13e4:	60 e0       	ldi	r22, 0x00	; 0
    13e6:	40 e0       	ldi	r20, 0x00	; 0
    13e8:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT_ID,DC_MOTOR_Second_PIN_ID,LOGIC_HIGH);
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	61 e0       	ldi	r22, 0x01	; 1
    13f0:	41 e0       	ldi	r20, 0x01	; 1
    13f2:	0e 94 8e 0b 	call	0x171c	; 0x171c <GPIO_writePin>
		break;
	default:
		/*Do Nothing*/
	break;
	}
}
    13f6:	0f 90       	pop	r0
    13f8:	0f 90       	pop	r0
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	cf 91       	pop	r28
    1400:	df 91       	pop	r29
    1402:	08 95       	ret

00001404 <EEPROM_writeByte>:
/*******************************************************************************
 *                      Functions Definitions                                   *
 *******************************************************************************/

uint8 EEPROM_writeByte(uint16 u16addr,uint8 u8data)
{
    1404:	df 93       	push	r29
    1406:	cf 93       	push	r28
    1408:	00 d0       	rcall	.+0      	; 0x140a <EEPROM_writeByte+0x6>
    140a:	00 d0       	rcall	.+0      	; 0x140c <EEPROM_writeByte+0x8>
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	9a 83       	std	Y+2, r25	; 0x02
    1412:	89 83       	std	Y+1, r24	; 0x01
    1414:	6b 83       	std	Y+3, r22	; 0x03
	/* 1. Send the Start Bit */
	TWI_start();
    1416:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <TWI_start>
	if(TWI_getStatus() != TWI_START)	return ERROR;
    141a:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    141e:	88 30       	cpi	r24, 0x08	; 8
    1420:	11 f0       	breq	.+4      	; 0x1426 <EEPROM_writeByte+0x22>
    1422:	1c 82       	std	Y+4, r1	; 0x04
    1424:	28 c0       	rjmp	.+80     	; 0x1476 <EEPROM_writeByte+0x72>

    /* 2. Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
	TWI_writeByte((uint8) ((0xA0) | ((u16addr&0x7000)>>7)));
    1426:	89 81       	ldd	r24, Y+1	; 0x01
    1428:	9a 81       	ldd	r25, Y+2	; 0x02
    142a:	80 70       	andi	r24, 0x00	; 0
    142c:	90 77       	andi	r25, 0x70	; 112
    142e:	88 0f       	add	r24, r24
    1430:	89 2f       	mov	r24, r25
    1432:	88 1f       	adc	r24, r24
    1434:	99 0b       	sbc	r25, r25
    1436:	91 95       	neg	r25
    1438:	80 6a       	ori	r24, 0xA0	; 160
    143a:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <TWI_writeByte>
	if(TWI_getStatus() !=  TWI_MT_SLA_W_ACK)	return ERROR;
    143e:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    1442:	88 31       	cpi	r24, 0x18	; 24
    1444:	11 f0       	breq	.+4      	; 0x144a <EEPROM_writeByte+0x46>
    1446:	1c 82       	std	Y+4, r1	; 0x04
    1448:	16 c0       	rjmp	.+44     	; 0x1476 <EEPROM_writeByte+0x72>

    /* 3. Send the required memory location address */
	TWI_writeByte((uint8) u16addr);
    144a:	89 81       	ldd	r24, Y+1	; 0x01
    144c:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <TWI_writeByte>
	if(TWI_getStatus() !=  TWI_MT_DATA_ACK)	return ERROR;
    1450:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    1454:	88 32       	cpi	r24, 0x28	; 40
    1456:	11 f0       	breq	.+4      	; 0x145c <EEPROM_writeByte+0x58>
    1458:	1c 82       	std	Y+4, r1	; 0x04
    145a:	0d c0       	rjmp	.+26     	; 0x1476 <EEPROM_writeByte+0x72>

    /* 4. write byte to eeprom */
	TWI_writeByte(u8data);
    145c:	8b 81       	ldd	r24, Y+3	; 0x03
    145e:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <TWI_writeByte>
	if(TWI_getStatus() !=  TWI_MT_DATA_ACK)	return ERROR;
    1462:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    1466:	88 32       	cpi	r24, 0x28	; 40
    1468:	11 f0       	breq	.+4      	; 0x146e <EEPROM_writeByte+0x6a>
    146a:	1c 82       	std	Y+4, r1	; 0x04
    146c:	04 c0       	rjmp	.+8      	; 0x1476 <EEPROM_writeByte+0x72>

    /* 5. Send the Stop Bit */
	TWI_stop();
    146e:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <TWI_stop>

	return SUCCESS;
    1472:	81 e0       	ldi	r24, 0x01	; 1
    1474:	8c 83       	std	Y+4, r24	; 0x04
    1476:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1478:	0f 90       	pop	r0
    147a:	0f 90       	pop	r0
    147c:	0f 90       	pop	r0
    147e:	0f 90       	pop	r0
    1480:	cf 91       	pop	r28
    1482:	df 91       	pop	r29
    1484:	08 95       	ret

00001486 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr,uint8 *u8data)
{
    1486:	df 93       	push	r29
    1488:	cf 93       	push	r28
    148a:	00 d0       	rcall	.+0      	; 0x148c <EEPROM_readByte+0x6>
    148c:	00 d0       	rcall	.+0      	; 0x148e <EEPROM_readByte+0x8>
    148e:	0f 92       	push	r0
    1490:	cd b7       	in	r28, 0x3d	; 61
    1492:	de b7       	in	r29, 0x3e	; 62
    1494:	9a 83       	std	Y+2, r25	; 0x02
    1496:	89 83       	std	Y+1, r24	; 0x01
    1498:	7c 83       	std	Y+4, r23	; 0x04
    149a:	6b 83       	std	Y+3, r22	; 0x03
	/* 1. Send the Start Bit */
	TWI_start();
    149c:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <TWI_start>
	if(TWI_getStatus() != TWI_START)	return ERROR;
    14a0:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    14a4:	88 30       	cpi	r24, 0x08	; 8
    14a6:	11 f0       	breq	.+4      	; 0x14ac <EEPROM_readByte+0x26>
    14a8:	1d 82       	std	Y+5, r1	; 0x05
    14aa:	44 c0       	rjmp	.+136    	; 0x1534 <EEPROM_readByte+0xae>

    /* 2. Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
	TWI_writeByte((uint8) ((0xA0) | ((u16addr&0x7000)>>7)));
    14ac:	89 81       	ldd	r24, Y+1	; 0x01
    14ae:	9a 81       	ldd	r25, Y+2	; 0x02
    14b0:	80 70       	andi	r24, 0x00	; 0
    14b2:	90 77       	andi	r25, 0x70	; 112
    14b4:	88 0f       	add	r24, r24
    14b6:	89 2f       	mov	r24, r25
    14b8:	88 1f       	adc	r24, r24
    14ba:	99 0b       	sbc	r25, r25
    14bc:	91 95       	neg	r25
    14be:	80 6a       	ori	r24, 0xA0	; 160
    14c0:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <TWI_writeByte>
	if(TWI_getStatus() !=  TWI_MT_SLA_W_ACK)	return ERROR;
    14c4:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    14c8:	88 31       	cpi	r24, 0x18	; 24
    14ca:	11 f0       	breq	.+4      	; 0x14d0 <EEPROM_readByte+0x4a>
    14cc:	1d 82       	std	Y+5, r1	; 0x05
    14ce:	32 c0       	rjmp	.+100    	; 0x1534 <EEPROM_readByte+0xae>

    /* 3. Send the required memory location address */
	TWI_writeByte((uint8) u16addr);
    14d0:	89 81       	ldd	r24, Y+1	; 0x01
    14d2:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <TWI_writeByte>
	if(TWI_getStatus() !=  TWI_MT_DATA_ACK)	return ERROR;
    14d6:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    14da:	88 32       	cpi	r24, 0x28	; 40
    14dc:	11 f0       	breq	.+4      	; 0x14e2 <EEPROM_readByte+0x5c>
    14de:	1d 82       	std	Y+5, r1	; 0x05
    14e0:	29 c0       	rjmp	.+82     	; 0x1534 <EEPROM_readByte+0xae>

	/* 4. Send the Repeated Start Bit */
	TWI_start();
    14e2:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <TWI_start>
	if(TWI_getStatus() != TWI_REP_START)	return ERROR;
    14e6:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    14ea:	80 31       	cpi	r24, 0x10	; 16
    14ec:	11 f0       	breq	.+4      	; 0x14f2 <EEPROM_readByte+0x6c>
    14ee:	1d 82       	std	Y+5, r1	; 0x05
    14f0:	21 c0       	rjmp	.+66     	; 0x1534 <EEPROM_readByte+0xae>


    /* 5. Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=1 (read) */
	TWI_writeByte((uint8) ((0xA0) | (((u16addr&0x7000)>>7) | 1)));
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
    14f4:	9a 81       	ldd	r25, Y+2	; 0x02
    14f6:	80 70       	andi	r24, 0x00	; 0
    14f8:	90 77       	andi	r25, 0x70	; 112
    14fa:	88 0f       	add	r24, r24
    14fc:	89 2f       	mov	r24, r25
    14fe:	88 1f       	adc	r24, r24
    1500:	99 0b       	sbc	r25, r25
    1502:	91 95       	neg	r25
    1504:	81 6a       	ori	r24, 0xA1	; 161
    1506:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <TWI_writeByte>
	if(TWI_getStatus() !=  TWI_MT_SLA_R_ACK)	return ERROR;
    150a:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    150e:	80 34       	cpi	r24, 0x40	; 64
    1510:	11 f0       	breq	.+4      	; 0x1516 <EEPROM_readByte+0x90>
    1512:	1d 82       	std	Y+5, r1	; 0x05
    1514:	0f c0       	rjmp	.+30     	; 0x1534 <EEPROM_readByte+0xae>

    /* 6. Read Byte from Memory without send ACK */
	*u8data = TWI_readByteWithNACK();
    1516:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <TWI_readByteWithNACK>
    151a:	eb 81       	ldd	r30, Y+3	; 0x03
    151c:	fc 81       	ldd	r31, Y+4	; 0x04
    151e:	80 83       	st	Z, r24
	if(TWI_getStatus() !=  TWI_MR_DATA_NACK)	return ERROR;
    1520:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <TWI_getStatus>
    1524:	88 35       	cpi	r24, 0x58	; 88
    1526:	11 f0       	breq	.+4      	; 0x152c <EEPROM_readByte+0xa6>
    1528:	1d 82       	std	Y+5, r1	; 0x05
    152a:	04 c0       	rjmp	.+8      	; 0x1534 <EEPROM_readByte+0xae>

    /* 7. Send the Stop Bit */
	TWI_stop();
    152c:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <TWI_stop>

	return SUCCESS;
    1530:	81 e0       	ldi	r24, 0x01	; 1
    1532:	8d 83       	std	Y+5, r24	; 0x05
    1534:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1536:	0f 90       	pop	r0
    1538:	0f 90       	pop	r0
    153a:	0f 90       	pop	r0
    153c:	0f 90       	pop	r0
    153e:	0f 90       	pop	r0
    1540:	cf 91       	pop	r28
    1542:	df 91       	pop	r29
    1544:	08 95       	ret

00001546 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
    1546:	df 93       	push	r29
    1548:	cf 93       	push	r28
    154a:	00 d0       	rcall	.+0      	; 0x154c <GPIO_setupPinDirection+0x6>
    154c:	00 d0       	rcall	.+0      	; 0x154e <GPIO_setupPinDirection+0x8>
    154e:	0f 92       	push	r0
    1550:	cd b7       	in	r28, 0x3d	; 61
    1552:	de b7       	in	r29, 0x3e	; 62
    1554:	89 83       	std	Y+1, r24	; 0x01
    1556:	6a 83       	std	Y+2, r22	; 0x02
    1558:	4b 83       	std	Y+3, r20	; 0x03
	if(port_num>= NUM_OF_PORTS || pin_num>= NUM_OF_PINS_PER_PORT)
    155a:	89 81       	ldd	r24, Y+1	; 0x01
    155c:	84 30       	cpi	r24, 0x04	; 4
    155e:	08 f0       	brcs	.+2      	; 0x1562 <GPIO_setupPinDirection+0x1c>
    1560:	d5 c0       	rjmp	.+426    	; 0x170c <GPIO_setupPinDirection+0x1c6>
    1562:	8a 81       	ldd	r24, Y+2	; 0x02
    1564:	88 30       	cpi	r24, 0x08	; 8
    1566:	08 f0       	brcs	.+2      	; 0x156a <GPIO_setupPinDirection+0x24>
    1568:	d1 c0       	rjmp	.+418    	; 0x170c <GPIO_setupPinDirection+0x1c6>
		/*Do Nothing*/
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
    156a:	89 81       	ldd	r24, Y+1	; 0x01
    156c:	28 2f       	mov	r18, r24
    156e:	30 e0       	ldi	r19, 0x00	; 0
    1570:	3d 83       	std	Y+5, r19	; 0x05
    1572:	2c 83       	std	Y+4, r18	; 0x04
    1574:	8c 81       	ldd	r24, Y+4	; 0x04
    1576:	9d 81       	ldd	r25, Y+5	; 0x05
    1578:	81 30       	cpi	r24, 0x01	; 1
    157a:	91 05       	cpc	r25, r1
    157c:	09 f4       	brne	.+2      	; 0x1580 <GPIO_setupPinDirection+0x3a>
    157e:	43 c0       	rjmp	.+134    	; 0x1606 <GPIO_setupPinDirection+0xc0>
    1580:	2c 81       	ldd	r18, Y+4	; 0x04
    1582:	3d 81       	ldd	r19, Y+5	; 0x05
    1584:	22 30       	cpi	r18, 0x02	; 2
    1586:	31 05       	cpc	r19, r1
    1588:	2c f4       	brge	.+10     	; 0x1594 <GPIO_setupPinDirection+0x4e>
    158a:	8c 81       	ldd	r24, Y+4	; 0x04
    158c:	9d 81       	ldd	r25, Y+5	; 0x05
    158e:	00 97       	sbiw	r24, 0x00	; 0
    1590:	71 f0       	breq	.+28     	; 0x15ae <GPIO_setupPinDirection+0x68>
    1592:	bc c0       	rjmp	.+376    	; 0x170c <GPIO_setupPinDirection+0x1c6>
    1594:	2c 81       	ldd	r18, Y+4	; 0x04
    1596:	3d 81       	ldd	r19, Y+5	; 0x05
    1598:	22 30       	cpi	r18, 0x02	; 2
    159a:	31 05       	cpc	r19, r1
    159c:	09 f4       	brne	.+2      	; 0x15a0 <GPIO_setupPinDirection+0x5a>
    159e:	5f c0       	rjmp	.+190    	; 0x165e <GPIO_setupPinDirection+0x118>
    15a0:	8c 81       	ldd	r24, Y+4	; 0x04
    15a2:	9d 81       	ldd	r25, Y+5	; 0x05
    15a4:	83 30       	cpi	r24, 0x03	; 3
    15a6:	91 05       	cpc	r25, r1
    15a8:	09 f4       	brne	.+2      	; 0x15ac <GPIO_setupPinDirection+0x66>
    15aa:	85 c0       	rjmp	.+266    	; 0x16b6 <GPIO_setupPinDirection+0x170>
    15ac:	af c0       	rjmp	.+350    	; 0x170c <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
    15ae:	8b 81       	ldd	r24, Y+3	; 0x03
    15b0:	81 30       	cpi	r24, 0x01	; 1
    15b2:	a1 f4       	brne	.+40     	; 0x15dc <GPIO_setupPinDirection+0x96>
				SET_BIT(DDRA, pin_num);
    15b4:	aa e3       	ldi	r26, 0x3A	; 58
    15b6:	b0 e0       	ldi	r27, 0x00	; 0
    15b8:	ea e3       	ldi	r30, 0x3A	; 58
    15ba:	f0 e0       	ldi	r31, 0x00	; 0
    15bc:	80 81       	ld	r24, Z
    15be:	48 2f       	mov	r20, r24
    15c0:	8a 81       	ldd	r24, Y+2	; 0x02
    15c2:	28 2f       	mov	r18, r24
    15c4:	30 e0       	ldi	r19, 0x00	; 0
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	02 2e       	mov	r0, r18
    15cc:	02 c0       	rjmp	.+4      	; 0x15d2 <GPIO_setupPinDirection+0x8c>
    15ce:	88 0f       	add	r24, r24
    15d0:	99 1f       	adc	r25, r25
    15d2:	0a 94       	dec	r0
    15d4:	e2 f7       	brpl	.-8      	; 0x15ce <GPIO_setupPinDirection+0x88>
    15d6:	84 2b       	or	r24, r20
    15d8:	8c 93       	st	X, r24
    15da:	98 c0       	rjmp	.+304    	; 0x170c <GPIO_setupPinDirection+0x1c6>
			else
				CLEAR_BIT(DDRA, pin_num);
    15dc:	aa e3       	ldi	r26, 0x3A	; 58
    15de:	b0 e0       	ldi	r27, 0x00	; 0
    15e0:	ea e3       	ldi	r30, 0x3A	; 58
    15e2:	f0 e0       	ldi	r31, 0x00	; 0
    15e4:	80 81       	ld	r24, Z
    15e6:	48 2f       	mov	r20, r24
    15e8:	8a 81       	ldd	r24, Y+2	; 0x02
    15ea:	28 2f       	mov	r18, r24
    15ec:	30 e0       	ldi	r19, 0x00	; 0
    15ee:	81 e0       	ldi	r24, 0x01	; 1
    15f0:	90 e0       	ldi	r25, 0x00	; 0
    15f2:	02 2e       	mov	r0, r18
    15f4:	02 c0       	rjmp	.+4      	; 0x15fa <GPIO_setupPinDirection+0xb4>
    15f6:	88 0f       	add	r24, r24
    15f8:	99 1f       	adc	r25, r25
    15fa:	0a 94       	dec	r0
    15fc:	e2 f7       	brpl	.-8      	; 0x15f6 <GPIO_setupPinDirection+0xb0>
    15fe:	80 95       	com	r24
    1600:	84 23       	and	r24, r20
    1602:	8c 93       	st	X, r24
    1604:	83 c0       	rjmp	.+262    	; 0x170c <GPIO_setupPinDirection+0x1c6>
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    1606:	8b 81       	ldd	r24, Y+3	; 0x03
    1608:	81 30       	cpi	r24, 0x01	; 1
    160a:	a1 f4       	brne	.+40     	; 0x1634 <GPIO_setupPinDirection+0xee>
				SET_BIT(DDRB, pin_num);
    160c:	a7 e3       	ldi	r26, 0x37	; 55
    160e:	b0 e0       	ldi	r27, 0x00	; 0
    1610:	e7 e3       	ldi	r30, 0x37	; 55
    1612:	f0 e0       	ldi	r31, 0x00	; 0
    1614:	80 81       	ld	r24, Z
    1616:	48 2f       	mov	r20, r24
    1618:	8a 81       	ldd	r24, Y+2	; 0x02
    161a:	28 2f       	mov	r18, r24
    161c:	30 e0       	ldi	r19, 0x00	; 0
    161e:	81 e0       	ldi	r24, 0x01	; 1
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	02 2e       	mov	r0, r18
    1624:	02 c0       	rjmp	.+4      	; 0x162a <GPIO_setupPinDirection+0xe4>
    1626:	88 0f       	add	r24, r24
    1628:	99 1f       	adc	r25, r25
    162a:	0a 94       	dec	r0
    162c:	e2 f7       	brpl	.-8      	; 0x1626 <GPIO_setupPinDirection+0xe0>
    162e:	84 2b       	or	r24, r20
    1630:	8c 93       	st	X, r24
    1632:	6c c0       	rjmp	.+216    	; 0x170c <GPIO_setupPinDirection+0x1c6>
			else
				CLEAR_BIT(DDRB, pin_num);
    1634:	a7 e3       	ldi	r26, 0x37	; 55
    1636:	b0 e0       	ldi	r27, 0x00	; 0
    1638:	e7 e3       	ldi	r30, 0x37	; 55
    163a:	f0 e0       	ldi	r31, 0x00	; 0
    163c:	80 81       	ld	r24, Z
    163e:	48 2f       	mov	r20, r24
    1640:	8a 81       	ldd	r24, Y+2	; 0x02
    1642:	28 2f       	mov	r18, r24
    1644:	30 e0       	ldi	r19, 0x00	; 0
    1646:	81 e0       	ldi	r24, 0x01	; 1
    1648:	90 e0       	ldi	r25, 0x00	; 0
    164a:	02 2e       	mov	r0, r18
    164c:	02 c0       	rjmp	.+4      	; 0x1652 <GPIO_setupPinDirection+0x10c>
    164e:	88 0f       	add	r24, r24
    1650:	99 1f       	adc	r25, r25
    1652:	0a 94       	dec	r0
    1654:	e2 f7       	brpl	.-8      	; 0x164e <GPIO_setupPinDirection+0x108>
    1656:	80 95       	com	r24
    1658:	84 23       	and	r24, r20
    165a:	8c 93       	st	X, r24
    165c:	57 c0       	rjmp	.+174    	; 0x170c <GPIO_setupPinDirection+0x1c6>
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    165e:	8b 81       	ldd	r24, Y+3	; 0x03
    1660:	81 30       	cpi	r24, 0x01	; 1
    1662:	a1 f4       	brne	.+40     	; 0x168c <GPIO_setupPinDirection+0x146>
				SET_BIT(DDRC, pin_num);
    1664:	a4 e3       	ldi	r26, 0x34	; 52
    1666:	b0 e0       	ldi	r27, 0x00	; 0
    1668:	e4 e3       	ldi	r30, 0x34	; 52
    166a:	f0 e0       	ldi	r31, 0x00	; 0
    166c:	80 81       	ld	r24, Z
    166e:	48 2f       	mov	r20, r24
    1670:	8a 81       	ldd	r24, Y+2	; 0x02
    1672:	28 2f       	mov	r18, r24
    1674:	30 e0       	ldi	r19, 0x00	; 0
    1676:	81 e0       	ldi	r24, 0x01	; 1
    1678:	90 e0       	ldi	r25, 0x00	; 0
    167a:	02 2e       	mov	r0, r18
    167c:	02 c0       	rjmp	.+4      	; 0x1682 <GPIO_setupPinDirection+0x13c>
    167e:	88 0f       	add	r24, r24
    1680:	99 1f       	adc	r25, r25
    1682:	0a 94       	dec	r0
    1684:	e2 f7       	brpl	.-8      	; 0x167e <GPIO_setupPinDirection+0x138>
    1686:	84 2b       	or	r24, r20
    1688:	8c 93       	st	X, r24
    168a:	40 c0       	rjmp	.+128    	; 0x170c <GPIO_setupPinDirection+0x1c6>
			else
				CLEAR_BIT(DDRC, pin_num);
    168c:	a4 e3       	ldi	r26, 0x34	; 52
    168e:	b0 e0       	ldi	r27, 0x00	; 0
    1690:	e4 e3       	ldi	r30, 0x34	; 52
    1692:	f0 e0       	ldi	r31, 0x00	; 0
    1694:	80 81       	ld	r24, Z
    1696:	48 2f       	mov	r20, r24
    1698:	8a 81       	ldd	r24, Y+2	; 0x02
    169a:	28 2f       	mov	r18, r24
    169c:	30 e0       	ldi	r19, 0x00	; 0
    169e:	81 e0       	ldi	r24, 0x01	; 1
    16a0:	90 e0       	ldi	r25, 0x00	; 0
    16a2:	02 2e       	mov	r0, r18
    16a4:	02 c0       	rjmp	.+4      	; 0x16aa <GPIO_setupPinDirection+0x164>
    16a6:	88 0f       	add	r24, r24
    16a8:	99 1f       	adc	r25, r25
    16aa:	0a 94       	dec	r0
    16ac:	e2 f7       	brpl	.-8      	; 0x16a6 <GPIO_setupPinDirection+0x160>
    16ae:	80 95       	com	r24
    16b0:	84 23       	and	r24, r20
    16b2:	8c 93       	st	X, r24
    16b4:	2b c0       	rjmp	.+86     	; 0x170c <GPIO_setupPinDirection+0x1c6>
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    16b6:	8b 81       	ldd	r24, Y+3	; 0x03
    16b8:	81 30       	cpi	r24, 0x01	; 1
    16ba:	a1 f4       	brne	.+40     	; 0x16e4 <GPIO_setupPinDirection+0x19e>
				SET_BIT(DDRD, pin_num);
    16bc:	a1 e3       	ldi	r26, 0x31	; 49
    16be:	b0 e0       	ldi	r27, 0x00	; 0
    16c0:	e1 e3       	ldi	r30, 0x31	; 49
    16c2:	f0 e0       	ldi	r31, 0x00	; 0
    16c4:	80 81       	ld	r24, Z
    16c6:	48 2f       	mov	r20, r24
    16c8:	8a 81       	ldd	r24, Y+2	; 0x02
    16ca:	28 2f       	mov	r18, r24
    16cc:	30 e0       	ldi	r19, 0x00	; 0
    16ce:	81 e0       	ldi	r24, 0x01	; 1
    16d0:	90 e0       	ldi	r25, 0x00	; 0
    16d2:	02 2e       	mov	r0, r18
    16d4:	02 c0       	rjmp	.+4      	; 0x16da <GPIO_setupPinDirection+0x194>
    16d6:	88 0f       	add	r24, r24
    16d8:	99 1f       	adc	r25, r25
    16da:	0a 94       	dec	r0
    16dc:	e2 f7       	brpl	.-8      	; 0x16d6 <GPIO_setupPinDirection+0x190>
    16de:	84 2b       	or	r24, r20
    16e0:	8c 93       	st	X, r24
    16e2:	14 c0       	rjmp	.+40     	; 0x170c <GPIO_setupPinDirection+0x1c6>
			else
				CLEAR_BIT(DDRD, pin_num);
    16e4:	a1 e3       	ldi	r26, 0x31	; 49
    16e6:	b0 e0       	ldi	r27, 0x00	; 0
    16e8:	e1 e3       	ldi	r30, 0x31	; 49
    16ea:	f0 e0       	ldi	r31, 0x00	; 0
    16ec:	80 81       	ld	r24, Z
    16ee:	48 2f       	mov	r20, r24
    16f0:	8a 81       	ldd	r24, Y+2	; 0x02
    16f2:	28 2f       	mov	r18, r24
    16f4:	30 e0       	ldi	r19, 0x00	; 0
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	02 2e       	mov	r0, r18
    16fc:	02 c0       	rjmp	.+4      	; 0x1702 <GPIO_setupPinDirection+0x1bc>
    16fe:	88 0f       	add	r24, r24
    1700:	99 1f       	adc	r25, r25
    1702:	0a 94       	dec	r0
    1704:	e2 f7       	brpl	.-8      	; 0x16fe <GPIO_setupPinDirection+0x1b8>
    1706:	80 95       	com	r24
    1708:	84 23       	and	r24, r20
    170a:	8c 93       	st	X, r24
			break;
		}
	}
}
    170c:	0f 90       	pop	r0
    170e:	0f 90       	pop	r0
    1710:	0f 90       	pop	r0
    1712:	0f 90       	pop	r0
    1714:	0f 90       	pop	r0
    1716:	cf 91       	pop	r28
    1718:	df 91       	pop	r29
    171a:	08 95       	ret

0000171c <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    171c:	df 93       	push	r29
    171e:	cf 93       	push	r28
    1720:	00 d0       	rcall	.+0      	; 0x1722 <GPIO_writePin+0x6>
    1722:	00 d0       	rcall	.+0      	; 0x1724 <GPIO_writePin+0x8>
    1724:	0f 92       	push	r0
    1726:	cd b7       	in	r28, 0x3d	; 61
    1728:	de b7       	in	r29, 0x3e	; 62
    172a:	89 83       	std	Y+1, r24	; 0x01
    172c:	6a 83       	std	Y+2, r22	; 0x02
    172e:	4b 83       	std	Y+3, r20	; 0x03
	if(port_num>= NUM_OF_PORTS || pin_num>= NUM_OF_PINS_PER_PORT)
    1730:	89 81       	ldd	r24, Y+1	; 0x01
    1732:	84 30       	cpi	r24, 0x04	; 4
    1734:	08 f0       	brcs	.+2      	; 0x1738 <GPIO_writePin+0x1c>
    1736:	d5 c0       	rjmp	.+426    	; 0x18e2 <GPIO_writePin+0x1c6>
    1738:	8a 81       	ldd	r24, Y+2	; 0x02
    173a:	88 30       	cpi	r24, 0x08	; 8
    173c:	08 f0       	brcs	.+2      	; 0x1740 <GPIO_writePin+0x24>
    173e:	d1 c0       	rjmp	.+418    	; 0x18e2 <GPIO_writePin+0x1c6>
	{
		/*Do Nothing*/
	}
	else
	{
		switch(port_num)
    1740:	89 81       	ldd	r24, Y+1	; 0x01
    1742:	28 2f       	mov	r18, r24
    1744:	30 e0       	ldi	r19, 0x00	; 0
    1746:	3d 83       	std	Y+5, r19	; 0x05
    1748:	2c 83       	std	Y+4, r18	; 0x04
    174a:	8c 81       	ldd	r24, Y+4	; 0x04
    174c:	9d 81       	ldd	r25, Y+5	; 0x05
    174e:	81 30       	cpi	r24, 0x01	; 1
    1750:	91 05       	cpc	r25, r1
    1752:	09 f4       	brne	.+2      	; 0x1756 <GPIO_writePin+0x3a>
    1754:	43 c0       	rjmp	.+134    	; 0x17dc <GPIO_writePin+0xc0>
    1756:	2c 81       	ldd	r18, Y+4	; 0x04
    1758:	3d 81       	ldd	r19, Y+5	; 0x05
    175a:	22 30       	cpi	r18, 0x02	; 2
    175c:	31 05       	cpc	r19, r1
    175e:	2c f4       	brge	.+10     	; 0x176a <GPIO_writePin+0x4e>
    1760:	8c 81       	ldd	r24, Y+4	; 0x04
    1762:	9d 81       	ldd	r25, Y+5	; 0x05
    1764:	00 97       	sbiw	r24, 0x00	; 0
    1766:	71 f0       	breq	.+28     	; 0x1784 <GPIO_writePin+0x68>
    1768:	bc c0       	rjmp	.+376    	; 0x18e2 <GPIO_writePin+0x1c6>
    176a:	2c 81       	ldd	r18, Y+4	; 0x04
    176c:	3d 81       	ldd	r19, Y+5	; 0x05
    176e:	22 30       	cpi	r18, 0x02	; 2
    1770:	31 05       	cpc	r19, r1
    1772:	09 f4       	brne	.+2      	; 0x1776 <GPIO_writePin+0x5a>
    1774:	5f c0       	rjmp	.+190    	; 0x1834 <GPIO_writePin+0x118>
    1776:	8c 81       	ldd	r24, Y+4	; 0x04
    1778:	9d 81       	ldd	r25, Y+5	; 0x05
    177a:	83 30       	cpi	r24, 0x03	; 3
    177c:	91 05       	cpc	r25, r1
    177e:	09 f4       	brne	.+2      	; 0x1782 <GPIO_writePin+0x66>
    1780:	85 c0       	rjmp	.+266    	; 0x188c <GPIO_writePin+0x170>
    1782:	af c0       	rjmp	.+350    	; 0x18e2 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    1784:	8b 81       	ldd	r24, Y+3	; 0x03
    1786:	81 30       	cpi	r24, 0x01	; 1
    1788:	a1 f4       	brne	.+40     	; 0x17b2 <GPIO_writePin+0x96>
				SET_BIT(PORTA,pin_num);
    178a:	ab e3       	ldi	r26, 0x3B	; 59
    178c:	b0 e0       	ldi	r27, 0x00	; 0
    178e:	eb e3       	ldi	r30, 0x3B	; 59
    1790:	f0 e0       	ldi	r31, 0x00	; 0
    1792:	80 81       	ld	r24, Z
    1794:	48 2f       	mov	r20, r24
    1796:	8a 81       	ldd	r24, Y+2	; 0x02
    1798:	28 2f       	mov	r18, r24
    179a:	30 e0       	ldi	r19, 0x00	; 0
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	90 e0       	ldi	r25, 0x00	; 0
    17a0:	02 2e       	mov	r0, r18
    17a2:	02 c0       	rjmp	.+4      	; 0x17a8 <GPIO_writePin+0x8c>
    17a4:	88 0f       	add	r24, r24
    17a6:	99 1f       	adc	r25, r25
    17a8:	0a 94       	dec	r0
    17aa:	e2 f7       	brpl	.-8      	; 0x17a4 <GPIO_writePin+0x88>
    17ac:	84 2b       	or	r24, r20
    17ae:	8c 93       	st	X, r24
    17b0:	98 c0       	rjmp	.+304    	; 0x18e2 <GPIO_writePin+0x1c6>
			else
				CLEAR_BIT(PORTA,pin_num);
    17b2:	ab e3       	ldi	r26, 0x3B	; 59
    17b4:	b0 e0       	ldi	r27, 0x00	; 0
    17b6:	eb e3       	ldi	r30, 0x3B	; 59
    17b8:	f0 e0       	ldi	r31, 0x00	; 0
    17ba:	80 81       	ld	r24, Z
    17bc:	48 2f       	mov	r20, r24
    17be:	8a 81       	ldd	r24, Y+2	; 0x02
    17c0:	28 2f       	mov	r18, r24
    17c2:	30 e0       	ldi	r19, 0x00	; 0
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	02 2e       	mov	r0, r18
    17ca:	02 c0       	rjmp	.+4      	; 0x17d0 <GPIO_writePin+0xb4>
    17cc:	88 0f       	add	r24, r24
    17ce:	99 1f       	adc	r25, r25
    17d0:	0a 94       	dec	r0
    17d2:	e2 f7       	brpl	.-8      	; 0x17cc <GPIO_writePin+0xb0>
    17d4:	80 95       	com	r24
    17d6:	84 23       	and	r24, r20
    17d8:	8c 93       	st	X, r24
    17da:	83 c0       	rjmp	.+262    	; 0x18e2 <GPIO_writePin+0x1c6>
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    17dc:	8b 81       	ldd	r24, Y+3	; 0x03
    17de:	81 30       	cpi	r24, 0x01	; 1
    17e0:	a1 f4       	brne	.+40     	; 0x180a <GPIO_writePin+0xee>
				SET_BIT(PORTB,pin_num);
    17e2:	a8 e3       	ldi	r26, 0x38	; 56
    17e4:	b0 e0       	ldi	r27, 0x00	; 0
    17e6:	e8 e3       	ldi	r30, 0x38	; 56
    17e8:	f0 e0       	ldi	r31, 0x00	; 0
    17ea:	80 81       	ld	r24, Z
    17ec:	48 2f       	mov	r20, r24
    17ee:	8a 81       	ldd	r24, Y+2	; 0x02
    17f0:	28 2f       	mov	r18, r24
    17f2:	30 e0       	ldi	r19, 0x00	; 0
    17f4:	81 e0       	ldi	r24, 0x01	; 1
    17f6:	90 e0       	ldi	r25, 0x00	; 0
    17f8:	02 2e       	mov	r0, r18
    17fa:	02 c0       	rjmp	.+4      	; 0x1800 <GPIO_writePin+0xe4>
    17fc:	88 0f       	add	r24, r24
    17fe:	99 1f       	adc	r25, r25
    1800:	0a 94       	dec	r0
    1802:	e2 f7       	brpl	.-8      	; 0x17fc <GPIO_writePin+0xe0>
    1804:	84 2b       	or	r24, r20
    1806:	8c 93       	st	X, r24
    1808:	6c c0       	rjmp	.+216    	; 0x18e2 <GPIO_writePin+0x1c6>
			else
				CLEAR_BIT(PORTB,pin_num);
    180a:	a8 e3       	ldi	r26, 0x38	; 56
    180c:	b0 e0       	ldi	r27, 0x00	; 0
    180e:	e8 e3       	ldi	r30, 0x38	; 56
    1810:	f0 e0       	ldi	r31, 0x00	; 0
    1812:	80 81       	ld	r24, Z
    1814:	48 2f       	mov	r20, r24
    1816:	8a 81       	ldd	r24, Y+2	; 0x02
    1818:	28 2f       	mov	r18, r24
    181a:	30 e0       	ldi	r19, 0x00	; 0
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	90 e0       	ldi	r25, 0x00	; 0
    1820:	02 2e       	mov	r0, r18
    1822:	02 c0       	rjmp	.+4      	; 0x1828 <GPIO_writePin+0x10c>
    1824:	88 0f       	add	r24, r24
    1826:	99 1f       	adc	r25, r25
    1828:	0a 94       	dec	r0
    182a:	e2 f7       	brpl	.-8      	; 0x1824 <GPIO_writePin+0x108>
    182c:	80 95       	com	r24
    182e:	84 23       	and	r24, r20
    1830:	8c 93       	st	X, r24
    1832:	57 c0       	rjmp	.+174    	; 0x18e2 <GPIO_writePin+0x1c6>
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    1834:	8b 81       	ldd	r24, Y+3	; 0x03
    1836:	81 30       	cpi	r24, 0x01	; 1
    1838:	a1 f4       	brne	.+40     	; 0x1862 <GPIO_writePin+0x146>
				SET_BIT(PORTC,pin_num);
    183a:	a5 e3       	ldi	r26, 0x35	; 53
    183c:	b0 e0       	ldi	r27, 0x00	; 0
    183e:	e5 e3       	ldi	r30, 0x35	; 53
    1840:	f0 e0       	ldi	r31, 0x00	; 0
    1842:	80 81       	ld	r24, Z
    1844:	48 2f       	mov	r20, r24
    1846:	8a 81       	ldd	r24, Y+2	; 0x02
    1848:	28 2f       	mov	r18, r24
    184a:	30 e0       	ldi	r19, 0x00	; 0
    184c:	81 e0       	ldi	r24, 0x01	; 1
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	02 2e       	mov	r0, r18
    1852:	02 c0       	rjmp	.+4      	; 0x1858 <GPIO_writePin+0x13c>
    1854:	88 0f       	add	r24, r24
    1856:	99 1f       	adc	r25, r25
    1858:	0a 94       	dec	r0
    185a:	e2 f7       	brpl	.-8      	; 0x1854 <GPIO_writePin+0x138>
    185c:	84 2b       	or	r24, r20
    185e:	8c 93       	st	X, r24
    1860:	40 c0       	rjmp	.+128    	; 0x18e2 <GPIO_writePin+0x1c6>
			else
				CLEAR_BIT(PORTC,pin_num);
    1862:	a5 e3       	ldi	r26, 0x35	; 53
    1864:	b0 e0       	ldi	r27, 0x00	; 0
    1866:	e5 e3       	ldi	r30, 0x35	; 53
    1868:	f0 e0       	ldi	r31, 0x00	; 0
    186a:	80 81       	ld	r24, Z
    186c:	48 2f       	mov	r20, r24
    186e:	8a 81       	ldd	r24, Y+2	; 0x02
    1870:	28 2f       	mov	r18, r24
    1872:	30 e0       	ldi	r19, 0x00	; 0
    1874:	81 e0       	ldi	r24, 0x01	; 1
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	02 2e       	mov	r0, r18
    187a:	02 c0       	rjmp	.+4      	; 0x1880 <GPIO_writePin+0x164>
    187c:	88 0f       	add	r24, r24
    187e:	99 1f       	adc	r25, r25
    1880:	0a 94       	dec	r0
    1882:	e2 f7       	brpl	.-8      	; 0x187c <GPIO_writePin+0x160>
    1884:	80 95       	com	r24
    1886:	84 23       	and	r24, r20
    1888:	8c 93       	st	X, r24
    188a:	2b c0       	rjmp	.+86     	; 0x18e2 <GPIO_writePin+0x1c6>
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    188c:	8b 81       	ldd	r24, Y+3	; 0x03
    188e:	81 30       	cpi	r24, 0x01	; 1
    1890:	a1 f4       	brne	.+40     	; 0x18ba <GPIO_writePin+0x19e>
				SET_BIT(PORTD,pin_num);
    1892:	a2 e3       	ldi	r26, 0x32	; 50
    1894:	b0 e0       	ldi	r27, 0x00	; 0
    1896:	e2 e3       	ldi	r30, 0x32	; 50
    1898:	f0 e0       	ldi	r31, 0x00	; 0
    189a:	80 81       	ld	r24, Z
    189c:	48 2f       	mov	r20, r24
    189e:	8a 81       	ldd	r24, Y+2	; 0x02
    18a0:	28 2f       	mov	r18, r24
    18a2:	30 e0       	ldi	r19, 0x00	; 0
    18a4:	81 e0       	ldi	r24, 0x01	; 1
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	02 2e       	mov	r0, r18
    18aa:	02 c0       	rjmp	.+4      	; 0x18b0 <GPIO_writePin+0x194>
    18ac:	88 0f       	add	r24, r24
    18ae:	99 1f       	adc	r25, r25
    18b0:	0a 94       	dec	r0
    18b2:	e2 f7       	brpl	.-8      	; 0x18ac <GPIO_writePin+0x190>
    18b4:	84 2b       	or	r24, r20
    18b6:	8c 93       	st	X, r24
    18b8:	14 c0       	rjmp	.+40     	; 0x18e2 <GPIO_writePin+0x1c6>
			else
				CLEAR_BIT(PORTD,pin_num);
    18ba:	a2 e3       	ldi	r26, 0x32	; 50
    18bc:	b0 e0       	ldi	r27, 0x00	; 0
    18be:	e2 e3       	ldi	r30, 0x32	; 50
    18c0:	f0 e0       	ldi	r31, 0x00	; 0
    18c2:	80 81       	ld	r24, Z
    18c4:	48 2f       	mov	r20, r24
    18c6:	8a 81       	ldd	r24, Y+2	; 0x02
    18c8:	28 2f       	mov	r18, r24
    18ca:	30 e0       	ldi	r19, 0x00	; 0
    18cc:	81 e0       	ldi	r24, 0x01	; 1
    18ce:	90 e0       	ldi	r25, 0x00	; 0
    18d0:	02 2e       	mov	r0, r18
    18d2:	02 c0       	rjmp	.+4      	; 0x18d8 <GPIO_writePin+0x1bc>
    18d4:	88 0f       	add	r24, r24
    18d6:	99 1f       	adc	r25, r25
    18d8:	0a 94       	dec	r0
    18da:	e2 f7       	brpl	.-8      	; 0x18d4 <GPIO_writePin+0x1b8>
    18dc:	80 95       	com	r24
    18de:	84 23       	and	r24, r20
    18e0:	8c 93       	st	X, r24
			break;
		}
	}
}
    18e2:	0f 90       	pop	r0
    18e4:	0f 90       	pop	r0
    18e6:	0f 90       	pop	r0
    18e8:	0f 90       	pop	r0
    18ea:	0f 90       	pop	r0
    18ec:	cf 91       	pop	r28
    18ee:	df 91       	pop	r29
    18f0:	08 95       	ret

000018f2 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    18f2:	df 93       	push	r29
    18f4:	cf 93       	push	r28
    18f6:	00 d0       	rcall	.+0      	; 0x18f8 <GPIO_readPin+0x6>
    18f8:	00 d0       	rcall	.+0      	; 0x18fa <GPIO_readPin+0x8>
    18fa:	0f 92       	push	r0
    18fc:	cd b7       	in	r28, 0x3d	; 61
    18fe:	de b7       	in	r29, 0x3e	; 62
    1900:	8a 83       	std	Y+2, r24	; 0x02
    1902:	6b 83       	std	Y+3, r22	; 0x03
	uint8 value = LOGIC_LOW;
    1904:	19 82       	std	Y+1, r1	; 0x01
	switch(port_num)
    1906:	8a 81       	ldd	r24, Y+2	; 0x02
    1908:	28 2f       	mov	r18, r24
    190a:	30 e0       	ldi	r19, 0x00	; 0
    190c:	3d 83       	std	Y+5, r19	; 0x05
    190e:	2c 83       	std	Y+4, r18	; 0x04
    1910:	4c 81       	ldd	r20, Y+4	; 0x04
    1912:	5d 81       	ldd	r21, Y+5	; 0x05
    1914:	41 30       	cpi	r20, 0x01	; 1
    1916:	51 05       	cpc	r21, r1
    1918:	79 f1       	breq	.+94     	; 0x1978 <GPIO_readPin+0x86>
    191a:	8c 81       	ldd	r24, Y+4	; 0x04
    191c:	9d 81       	ldd	r25, Y+5	; 0x05
    191e:	82 30       	cpi	r24, 0x02	; 2
    1920:	91 05       	cpc	r25, r1
    1922:	34 f4       	brge	.+12     	; 0x1930 <GPIO_readPin+0x3e>
    1924:	2c 81       	ldd	r18, Y+4	; 0x04
    1926:	3d 81       	ldd	r19, Y+5	; 0x05
    1928:	21 15       	cp	r18, r1
    192a:	31 05       	cpc	r19, r1
    192c:	69 f0       	breq	.+26     	; 0x1948 <GPIO_readPin+0x56>
    192e:	6b c0       	rjmp	.+214    	; 0x1a06 <GPIO_readPin+0x114>
    1930:	4c 81       	ldd	r20, Y+4	; 0x04
    1932:	5d 81       	ldd	r21, Y+5	; 0x05
    1934:	42 30       	cpi	r20, 0x02	; 2
    1936:	51 05       	cpc	r21, r1
    1938:	b9 f1       	breq	.+110    	; 0x19a8 <GPIO_readPin+0xb6>
    193a:	8c 81       	ldd	r24, Y+4	; 0x04
    193c:	9d 81       	ldd	r25, Y+5	; 0x05
    193e:	83 30       	cpi	r24, 0x03	; 3
    1940:	91 05       	cpc	r25, r1
    1942:	09 f4       	brne	.+2      	; 0x1946 <GPIO_readPin+0x54>
    1944:	49 c0       	rjmp	.+146    	; 0x19d8 <GPIO_readPin+0xe6>
    1946:	5f c0       	rjmp	.+190    	; 0x1a06 <GPIO_readPin+0x114>
	{
	case PORTA_ID:
		if(BIT_IS_SET(PINA,pin_num))
    1948:	e9 e3       	ldi	r30, 0x39	; 57
    194a:	f0 e0       	ldi	r31, 0x00	; 0
    194c:	80 81       	ld	r24, Z
    194e:	28 2f       	mov	r18, r24
    1950:	30 e0       	ldi	r19, 0x00	; 0
    1952:	8b 81       	ldd	r24, Y+3	; 0x03
    1954:	88 2f       	mov	r24, r24
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	a9 01       	movw	r20, r18
    195a:	02 c0       	rjmp	.+4      	; 0x1960 <GPIO_readPin+0x6e>
    195c:	55 95       	asr	r21
    195e:	47 95       	ror	r20
    1960:	8a 95       	dec	r24
    1962:	e2 f7       	brpl	.-8      	; 0x195c <GPIO_readPin+0x6a>
    1964:	ca 01       	movw	r24, r20
    1966:	81 70       	andi	r24, 0x01	; 1
    1968:	90 70       	andi	r25, 0x00	; 0
    196a:	88 23       	and	r24, r24
    196c:	19 f0       	breq	.+6      	; 0x1974 <GPIO_readPin+0x82>
			value = LOGIC_HIGH;
    196e:	81 e0       	ldi	r24, 0x01	; 1
    1970:	89 83       	std	Y+1, r24	; 0x01
    1972:	49 c0       	rjmp	.+146    	; 0x1a06 <GPIO_readPin+0x114>
		else
			value = LOGIC_LOW;
    1974:	19 82       	std	Y+1, r1	; 0x01
    1976:	47 c0       	rjmp	.+142    	; 0x1a06 <GPIO_readPin+0x114>
		break;
	case PORTB_ID:
		if(BIT_IS_SET(PINB,pin_num))
    1978:	e6 e3       	ldi	r30, 0x36	; 54
    197a:	f0 e0       	ldi	r31, 0x00	; 0
    197c:	80 81       	ld	r24, Z
    197e:	28 2f       	mov	r18, r24
    1980:	30 e0       	ldi	r19, 0x00	; 0
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	88 2f       	mov	r24, r24
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	a9 01       	movw	r20, r18
    198a:	02 c0       	rjmp	.+4      	; 0x1990 <GPIO_readPin+0x9e>
    198c:	55 95       	asr	r21
    198e:	47 95       	ror	r20
    1990:	8a 95       	dec	r24
    1992:	e2 f7       	brpl	.-8      	; 0x198c <GPIO_readPin+0x9a>
    1994:	ca 01       	movw	r24, r20
    1996:	81 70       	andi	r24, 0x01	; 1
    1998:	90 70       	andi	r25, 0x00	; 0
    199a:	88 23       	and	r24, r24
    199c:	19 f0       	breq	.+6      	; 0x19a4 <GPIO_readPin+0xb2>
			value = LOGIC_HIGH;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	89 83       	std	Y+1, r24	; 0x01
    19a2:	31 c0       	rjmp	.+98     	; 0x1a06 <GPIO_readPin+0x114>
		else
			value = LOGIC_LOW;
    19a4:	19 82       	std	Y+1, r1	; 0x01
    19a6:	2f c0       	rjmp	.+94     	; 0x1a06 <GPIO_readPin+0x114>
		break;
	case PORTC_ID:
		if(BIT_IS_SET(PINC,pin_num))
    19a8:	e3 e3       	ldi	r30, 0x33	; 51
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	80 81       	ld	r24, Z
    19ae:	28 2f       	mov	r18, r24
    19b0:	30 e0       	ldi	r19, 0x00	; 0
    19b2:	8b 81       	ldd	r24, Y+3	; 0x03
    19b4:	88 2f       	mov	r24, r24
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	a9 01       	movw	r20, r18
    19ba:	02 c0       	rjmp	.+4      	; 0x19c0 <GPIO_readPin+0xce>
    19bc:	55 95       	asr	r21
    19be:	47 95       	ror	r20
    19c0:	8a 95       	dec	r24
    19c2:	e2 f7       	brpl	.-8      	; 0x19bc <GPIO_readPin+0xca>
    19c4:	ca 01       	movw	r24, r20
    19c6:	81 70       	andi	r24, 0x01	; 1
    19c8:	90 70       	andi	r25, 0x00	; 0
    19ca:	88 23       	and	r24, r24
    19cc:	19 f0       	breq	.+6      	; 0x19d4 <GPIO_readPin+0xe2>
			value = LOGIC_HIGH;
    19ce:	81 e0       	ldi	r24, 0x01	; 1
    19d0:	89 83       	std	Y+1, r24	; 0x01
    19d2:	19 c0       	rjmp	.+50     	; 0x1a06 <GPIO_readPin+0x114>
		else
			value = LOGIC_LOW;
    19d4:	19 82       	std	Y+1, r1	; 0x01
    19d6:	17 c0       	rjmp	.+46     	; 0x1a06 <GPIO_readPin+0x114>
		break;
	case PORTD_ID:
		if(BIT_IS_SET(PIND,pin_num))
    19d8:	e0 e3       	ldi	r30, 0x30	; 48
    19da:	f0 e0       	ldi	r31, 0x00	; 0
    19dc:	80 81       	ld	r24, Z
    19de:	28 2f       	mov	r18, r24
    19e0:	30 e0       	ldi	r19, 0x00	; 0
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	88 2f       	mov	r24, r24
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	a9 01       	movw	r20, r18
    19ea:	02 c0       	rjmp	.+4      	; 0x19f0 <GPIO_readPin+0xfe>
    19ec:	55 95       	asr	r21
    19ee:	47 95       	ror	r20
    19f0:	8a 95       	dec	r24
    19f2:	e2 f7       	brpl	.-8      	; 0x19ec <GPIO_readPin+0xfa>
    19f4:	ca 01       	movw	r24, r20
    19f6:	81 70       	andi	r24, 0x01	; 1
    19f8:	90 70       	andi	r25, 0x00	; 0
    19fa:	88 23       	and	r24, r24
    19fc:	19 f0       	breq	.+6      	; 0x1a04 <GPIO_readPin+0x112>
			value = LOGIC_HIGH;
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	89 83       	std	Y+1, r24	; 0x01
    1a02:	01 c0       	rjmp	.+2      	; 0x1a06 <GPIO_readPin+0x114>
		else
			value = LOGIC_LOW;
    1a04:	19 82       	std	Y+1, r1	; 0x01
		break;
	}
	return value;
    1a06:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a08:	0f 90       	pop	r0
    1a0a:	0f 90       	pop	r0
    1a0c:	0f 90       	pop	r0
    1a0e:	0f 90       	pop	r0
    1a10:	0f 90       	pop	r0
    1a12:	cf 91       	pop	r28
    1a14:	df 91       	pop	r29
    1a16:	08 95       	ret

00001a18 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    1a18:	df 93       	push	r29
    1a1a:	cf 93       	push	r28
    1a1c:	00 d0       	rcall	.+0      	; 0x1a1e <GPIO_setupPortDirection+0x6>
    1a1e:	00 d0       	rcall	.+0      	; 0x1a20 <GPIO_setupPortDirection+0x8>
    1a20:	cd b7       	in	r28, 0x3d	; 61
    1a22:	de b7       	in	r29, 0x3e	; 62
    1a24:	89 83       	std	Y+1, r24	; 0x01
    1a26:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num>=NUM_OF_PORTS)
    1a28:	89 81       	ldd	r24, Y+1	; 0x01
    1a2a:	84 30       	cpi	r24, 0x04	; 4
    1a2c:	90 f5       	brcc	.+100    	; 0x1a92 <GPIO_setupPortDirection+0x7a>
		/*Do Nothing*/
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    1a2e:	89 81       	ldd	r24, Y+1	; 0x01
    1a30:	28 2f       	mov	r18, r24
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	3c 83       	std	Y+4, r19	; 0x04
    1a36:	2b 83       	std	Y+3, r18	; 0x03
    1a38:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a3c:	81 30       	cpi	r24, 0x01	; 1
    1a3e:	91 05       	cpc	r25, r1
    1a40:	d1 f0       	breq	.+52     	; 0x1a76 <GPIO_setupPortDirection+0x5e>
    1a42:	2b 81       	ldd	r18, Y+3	; 0x03
    1a44:	3c 81       	ldd	r19, Y+4	; 0x04
    1a46:	22 30       	cpi	r18, 0x02	; 2
    1a48:	31 05       	cpc	r19, r1
    1a4a:	2c f4       	brge	.+10     	; 0x1a56 <GPIO_setupPortDirection+0x3e>
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a50:	00 97       	sbiw	r24, 0x00	; 0
    1a52:	61 f0       	breq	.+24     	; 0x1a6c <GPIO_setupPortDirection+0x54>
    1a54:	1e c0       	rjmp	.+60     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
    1a56:	2b 81       	ldd	r18, Y+3	; 0x03
    1a58:	3c 81       	ldd	r19, Y+4	; 0x04
    1a5a:	22 30       	cpi	r18, 0x02	; 2
    1a5c:	31 05       	cpc	r19, r1
    1a5e:	81 f0       	breq	.+32     	; 0x1a80 <GPIO_setupPortDirection+0x68>
    1a60:	8b 81       	ldd	r24, Y+3	; 0x03
    1a62:	9c 81       	ldd	r25, Y+4	; 0x04
    1a64:	83 30       	cpi	r24, 0x03	; 3
    1a66:	91 05       	cpc	r25, r1
    1a68:	81 f0       	breq	.+32     	; 0x1a8a <GPIO_setupPortDirection+0x72>
    1a6a:	13 c0       	rjmp	.+38     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    1a6c:	ea e3       	ldi	r30, 0x3A	; 58
    1a6e:	f0 e0       	ldi	r31, 0x00	; 0
    1a70:	8a 81       	ldd	r24, Y+2	; 0x02
    1a72:	80 83       	st	Z, r24
    1a74:	0e c0       	rjmp	.+28     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    1a76:	e7 e3       	ldi	r30, 0x37	; 55
    1a78:	f0 e0       	ldi	r31, 0x00	; 0
    1a7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7c:	80 83       	st	Z, r24
    1a7e:	09 c0       	rjmp	.+18     	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    1a80:	e4 e3       	ldi	r30, 0x34	; 52
    1a82:	f0 e0       	ldi	r31, 0x00	; 0
    1a84:	8a 81       	ldd	r24, Y+2	; 0x02
    1a86:	80 83       	st	Z, r24
    1a88:	04 c0       	rjmp	.+8      	; 0x1a92 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    1a8a:	e1 e3       	ldi	r30, 0x31	; 49
    1a8c:	f0 e0       	ldi	r31, 0x00	; 0
    1a8e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a90:	80 83       	st	Z, r24
			break;
		}
	}
}
    1a92:	0f 90       	pop	r0
    1a94:	0f 90       	pop	r0
    1a96:	0f 90       	pop	r0
    1a98:	0f 90       	pop	r0
    1a9a:	cf 91       	pop	r28
    1a9c:	df 91       	pop	r29
    1a9e:	08 95       	ret

00001aa0 <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    1aa0:	df 93       	push	r29
    1aa2:	cf 93       	push	r28
    1aa4:	00 d0       	rcall	.+0      	; 0x1aa6 <GPIO_writePort+0x6>
    1aa6:	00 d0       	rcall	.+0      	; 0x1aa8 <GPIO_writePort+0x8>
    1aa8:	cd b7       	in	r28, 0x3d	; 61
    1aaa:	de b7       	in	r29, 0x3e	; 62
    1aac:	89 83       	std	Y+1, r24	; 0x01
    1aae:	6a 83       	std	Y+2, r22	; 0x02
	if(port_num>=NUM_OF_PORTS)
    1ab0:	89 81       	ldd	r24, Y+1	; 0x01
    1ab2:	84 30       	cpi	r24, 0x04	; 4
    1ab4:	90 f5       	brcc	.+100    	; 0x1b1a <GPIO_writePort+0x7a>
	{
			/*Do Nothing*/
	}
	else
	{
		switch(port_num)
    1ab6:	89 81       	ldd	r24, Y+1	; 0x01
    1ab8:	28 2f       	mov	r18, r24
    1aba:	30 e0       	ldi	r19, 0x00	; 0
    1abc:	3c 83       	std	Y+4, r19	; 0x04
    1abe:	2b 83       	std	Y+3, r18	; 0x03
    1ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	91 05       	cpc	r25, r1
    1ac8:	d1 f0       	breq	.+52     	; 0x1afe <GPIO_writePort+0x5e>
    1aca:	2b 81       	ldd	r18, Y+3	; 0x03
    1acc:	3c 81       	ldd	r19, Y+4	; 0x04
    1ace:	22 30       	cpi	r18, 0x02	; 2
    1ad0:	31 05       	cpc	r19, r1
    1ad2:	2c f4       	brge	.+10     	; 0x1ade <GPIO_writePort+0x3e>
    1ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad8:	00 97       	sbiw	r24, 0x00	; 0
    1ada:	61 f0       	breq	.+24     	; 0x1af4 <GPIO_writePort+0x54>
    1adc:	1e c0       	rjmp	.+60     	; 0x1b1a <GPIO_writePort+0x7a>
    1ade:	2b 81       	ldd	r18, Y+3	; 0x03
    1ae0:	3c 81       	ldd	r19, Y+4	; 0x04
    1ae2:	22 30       	cpi	r18, 0x02	; 2
    1ae4:	31 05       	cpc	r19, r1
    1ae6:	81 f0       	breq	.+32     	; 0x1b08 <GPIO_writePort+0x68>
    1ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aea:	9c 81       	ldd	r25, Y+4	; 0x04
    1aec:	83 30       	cpi	r24, 0x03	; 3
    1aee:	91 05       	cpc	r25, r1
    1af0:	81 f0       	breq	.+32     	; 0x1b12 <GPIO_writePort+0x72>
    1af2:	13 c0       	rjmp	.+38     	; 0x1b1a <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    1af4:	eb e3       	ldi	r30, 0x3B	; 59
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	8a 81       	ldd	r24, Y+2	; 0x02
    1afa:	80 83       	st	Z, r24
    1afc:	0e c0       	rjmp	.+28     	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    1afe:	e8 e3       	ldi	r30, 0x38	; 56
    1b00:	f0 e0       	ldi	r31, 0x00	; 0
    1b02:	8a 81       	ldd	r24, Y+2	; 0x02
    1b04:	80 83       	st	Z, r24
    1b06:	09 c0       	rjmp	.+18     	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    1b08:	e5 e3       	ldi	r30, 0x35	; 53
    1b0a:	f0 e0       	ldi	r31, 0x00	; 0
    1b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b0e:	80 83       	st	Z, r24
    1b10:	04 c0       	rjmp	.+8      	; 0x1b1a <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    1b12:	e2 e3       	ldi	r30, 0x32	; 50
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	8a 81       	ldd	r24, Y+2	; 0x02
    1b18:	80 83       	st	Z, r24
			break;
		}
	}
}
    1b1a:	0f 90       	pop	r0
    1b1c:	0f 90       	pop	r0
    1b1e:	0f 90       	pop	r0
    1b20:	0f 90       	pop	r0
    1b22:	cf 91       	pop	r28
    1b24:	df 91       	pop	r29
    1b26:	08 95       	ret

00001b28 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    1b28:	df 93       	push	r29
    1b2a:	cf 93       	push	r28
    1b2c:	00 d0       	rcall	.+0      	; 0x1b2e <GPIO_readPort+0x6>
    1b2e:	00 d0       	rcall	.+0      	; 0x1b30 <GPIO_readPort+0x8>
    1b30:	cd b7       	in	r28, 0x3d	; 61
    1b32:	de b7       	in	r29, 0x3e	; 62
    1b34:	8a 83       	std	Y+2, r24	; 0x02
	/* set the default of the value = Zero */
	uint8 value = LOGIC_LOW;
    1b36:	19 82       	std	Y+1, r1	; 0x01
	if(port_num>=NUM_OF_PORTS)
    1b38:	8a 81       	ldd	r24, Y+2	; 0x02
    1b3a:	84 30       	cpi	r24, 0x04	; 4
    1b3c:	90 f5       	brcc	.+100    	; 0x1ba2 <GPIO_readPort+0x7a>
	{
			/*Do Nothing*/
	}
	else
	{
		switch(port_num)
    1b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b40:	28 2f       	mov	r18, r24
    1b42:	30 e0       	ldi	r19, 0x00	; 0
    1b44:	3c 83       	std	Y+4, r19	; 0x04
    1b46:	2b 83       	std	Y+3, r18	; 0x03
    1b48:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4c:	81 30       	cpi	r24, 0x01	; 1
    1b4e:	91 05       	cpc	r25, r1
    1b50:	d1 f0       	breq	.+52     	; 0x1b86 <GPIO_readPort+0x5e>
    1b52:	2b 81       	ldd	r18, Y+3	; 0x03
    1b54:	3c 81       	ldd	r19, Y+4	; 0x04
    1b56:	22 30       	cpi	r18, 0x02	; 2
    1b58:	31 05       	cpc	r19, r1
    1b5a:	2c f4       	brge	.+10     	; 0x1b66 <GPIO_readPort+0x3e>
    1b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b60:	00 97       	sbiw	r24, 0x00	; 0
    1b62:	61 f0       	breq	.+24     	; 0x1b7c <GPIO_readPort+0x54>
    1b64:	1e c0       	rjmp	.+60     	; 0x1ba2 <GPIO_readPort+0x7a>
    1b66:	2b 81       	ldd	r18, Y+3	; 0x03
    1b68:	3c 81       	ldd	r19, Y+4	; 0x04
    1b6a:	22 30       	cpi	r18, 0x02	; 2
    1b6c:	31 05       	cpc	r19, r1
    1b6e:	81 f0       	breq	.+32     	; 0x1b90 <GPIO_readPort+0x68>
    1b70:	8b 81       	ldd	r24, Y+3	; 0x03
    1b72:	9c 81       	ldd	r25, Y+4	; 0x04
    1b74:	83 30       	cpi	r24, 0x03	; 3
    1b76:	91 05       	cpc	r25, r1
    1b78:	81 f0       	breq	.+32     	; 0x1b9a <GPIO_readPort+0x72>
    1b7a:	13 c0       	rjmp	.+38     	; 0x1ba2 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    1b7c:	e9 e3       	ldi	r30, 0x39	; 57
    1b7e:	f0 e0       	ldi	r31, 0x00	; 0
    1b80:	80 81       	ld	r24, Z
    1b82:	89 83       	std	Y+1, r24	; 0x01
    1b84:	0e c0       	rjmp	.+28     	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    1b86:	e6 e3       	ldi	r30, 0x36	; 54
    1b88:	f0 e0       	ldi	r31, 0x00	; 0
    1b8a:	80 81       	ld	r24, Z
    1b8c:	89 83       	std	Y+1, r24	; 0x01
    1b8e:	09 c0       	rjmp	.+18     	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    1b90:	e3 e3       	ldi	r30, 0x33	; 51
    1b92:	f0 e0       	ldi	r31, 0x00	; 0
    1b94:	80 81       	ld	r24, Z
    1b96:	89 83       	std	Y+1, r24	; 0x01
    1b98:	04 c0       	rjmp	.+8      	; 0x1ba2 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    1b9a:	e0 e3       	ldi	r30, 0x30	; 48
    1b9c:	f0 e0       	ldi	r31, 0x00	; 0
    1b9e:	80 81       	ld	r24, Z
    1ba0:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}
	return value;
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ba4:	0f 90       	pop	r0
    1ba6:	0f 90       	pop	r0
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	cf 91       	pop	r28
    1bae:	df 91       	pop	r29
    1bb0:	08 95       	ret

00001bb2 <PWM_Timer0_Start>:
 Setup the compare value based on the required input duty cycle
 Setup the direction for OC0 as output pin through the GPIO driver.
 The generated PWM signal frequency will be 500Hz to control the DC Motor speed.
 */
void PWM_Timer0_Start (uint8 duty_cycle)
{
    1bb2:	0f 93       	push	r16
    1bb4:	1f 93       	push	r17
    1bb6:	df 93       	push	r29
    1bb8:	cf 93       	push	r28
    1bba:	0f 92       	push	r0
    1bbc:	cd b7       	in	r28, 0x3d	; 61
    1bbe:	de b7       	in	r29, 0x3e	; 62
    1bc0:	89 83       	std	Y+1, r24	; 0x01

	/* 1.  Set Timer Initial Value to 0*/
	TCNT0 = 0;
    1bc2:	e2 e5       	ldi	r30, 0x52	; 82
    1bc4:	f0 e0       	ldi	r31, 0x00	; 0
    1bc6:	10 82       	st	Z, r1

	/* 2. set the compare value in OCR0*/
		/*The DutyCycle Is In Percentage So We Have To Make Some Calculations*/
	OCR0=(uint8)(((float32)duty_cycle/100)*255);
    1bc8:	0c e5       	ldi	r16, 0x5C	; 92
    1bca:	10 e0       	ldi	r17, 0x00	; 0
    1bcc:	89 81       	ldd	r24, Y+1	; 0x01
    1bce:	88 2f       	mov	r24, r24
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	a0 e0       	ldi	r26, 0x00	; 0
    1bd4:	b0 e0       	ldi	r27, 0x00	; 0
    1bd6:	bc 01       	movw	r22, r24
    1bd8:	cd 01       	movw	r24, r26
    1bda:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1bde:	dc 01       	movw	r26, r24
    1be0:	cb 01       	movw	r24, r22
    1be2:	bc 01       	movw	r22, r24
    1be4:	cd 01       	movw	r24, r26
    1be6:	20 e0       	ldi	r18, 0x00	; 0
    1be8:	30 e0       	ldi	r19, 0x00	; 0
    1bea:	48 ec       	ldi	r20, 0xC8	; 200
    1bec:	52 e4       	ldi	r21, 0x42	; 66
    1bee:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1bf2:	dc 01       	movw	r26, r24
    1bf4:	cb 01       	movw	r24, r22
    1bf6:	bc 01       	movw	r22, r24
    1bf8:	cd 01       	movw	r24, r26
    1bfa:	20 e0       	ldi	r18, 0x00	; 0
    1bfc:	30 e0       	ldi	r19, 0x00	; 0
    1bfe:	4f e7       	ldi	r20, 0x7F	; 127
    1c00:	53 e4       	ldi	r21, 0x43	; 67
    1c02:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c06:	dc 01       	movw	r26, r24
    1c08:	cb 01       	movw	r24, r22
    1c0a:	bc 01       	movw	r22, r24
    1c0c:	cd 01       	movw	r24, r26
    1c0e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c12:	dc 01       	movw	r26, r24
    1c14:	cb 01       	movw	r24, r22
    1c16:	f8 01       	movw	r30, r16
    1c18:	80 83       	st	Z, r24

	/* 3. configure PB3/OC0 as output
	      pin --> pin where the PWM signal is generated from MC
	*/
	SET_BIT(PWM_PORT_ID,PWM_PIN_ID);
    1c1a:	a7 e3       	ldi	r26, 0x37	; 55
    1c1c:	b0 e0       	ldi	r27, 0x00	; 0
    1c1e:	e7 e3       	ldi	r30, 0x37	; 55
    1c20:	f0 e0       	ldi	r31, 0x00	; 0
    1c22:	80 81       	ld	r24, Z
    1c24:	88 60       	ori	r24, 0x08	; 8
    1c26:	8c 93       	st	X, r24
	 *		 a. Fast PWM mode FOC0=0
	 *		 b. Fast PWM Mode WGM01=1 & WGM00=1
	 * 		 c. Clear OC0 when match occurs (non inverted mode) =>  COM00=0 & COM01=1
	 * 		 d. clock = F_CPU/8 CS00=0 CS01=1 CS02=0
	 */
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS01);
    1c28:	e3 e5       	ldi	r30, 0x53	; 83
    1c2a:	f0 e0       	ldi	r31, 0x00	; 0
    1c2c:	8a e6       	ldi	r24, 0x6A	; 106
    1c2e:	80 83       	st	Z, r24
}
    1c30:	0f 90       	pop	r0
    1c32:	cf 91       	pop	r28
    1c34:	df 91       	pop	r29
    1c36:	1f 91       	pop	r17
    1c38:	0f 91       	pop	r16
    1c3a:	08 95       	ret

00001c3c <__vector_7>:
 *                       Interrupt Service Routines                            *
 *******************************************************************************/
#ifdef TIMER1_COMPARE
#if(CTC_CHANNEL == A)
ISR(TIMER1_COMPA_vect)
{
    1c3c:	1f 92       	push	r1
    1c3e:	0f 92       	push	r0
    1c40:	0f b6       	in	r0, 0x3f	; 63
    1c42:	0f 92       	push	r0
    1c44:	11 24       	eor	r1, r1
    1c46:	2f 93       	push	r18
    1c48:	3f 93       	push	r19
    1c4a:	4f 93       	push	r20
    1c4c:	5f 93       	push	r21
    1c4e:	6f 93       	push	r22
    1c50:	7f 93       	push	r23
    1c52:	8f 93       	push	r24
    1c54:	9f 93       	push	r25
    1c56:	af 93       	push	r26
    1c58:	bf 93       	push	r27
    1c5a:	ef 93       	push	r30
    1c5c:	ff 93       	push	r31
    1c5e:	df 93       	push	r29
    1c60:	cf 93       	push	r28
    1c62:	cd b7       	in	r28, 0x3d	; 61
    1c64:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
    1c66:	80 91 7d 01 	lds	r24, 0x017D
    1c6a:	90 91 7e 01 	lds	r25, 0x017E
    1c6e:	00 97       	sbiw	r24, 0x00	; 0
    1c70:	29 f0       	breq	.+10     	; 0x1c7c <__vector_7+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
    1c72:	e0 91 7d 01 	lds	r30, 0x017D
    1c76:	f0 91 7e 01 	lds	r31, 0x017E
    1c7a:	09 95       	icall
	}
}
    1c7c:	cf 91       	pop	r28
    1c7e:	df 91       	pop	r29
    1c80:	ff 91       	pop	r31
    1c82:	ef 91       	pop	r30
    1c84:	bf 91       	pop	r27
    1c86:	af 91       	pop	r26
    1c88:	9f 91       	pop	r25
    1c8a:	8f 91       	pop	r24
    1c8c:	7f 91       	pop	r23
    1c8e:	6f 91       	pop	r22
    1c90:	5f 91       	pop	r21
    1c92:	4f 91       	pop	r20
    1c94:	3f 91       	pop	r19
    1c96:	2f 91       	pop	r18
    1c98:	0f 90       	pop	r0
    1c9a:	0f be       	out	0x3f, r0	; 63
    1c9c:	0f 90       	pop	r0
    1c9e:	1f 90       	pop	r1
    1ca0:	18 95       	reti

00001ca2 <Timer1_init>:
  	   Function to initialize the Timer driver
 Inputs: pointer to the configuration structure with type Timer1_ConfigType.
 Return: None
 */
void Timer1_init(const Timer1_ConfigType * Config_Ptr)
{
    1ca2:	df 93       	push	r29
    1ca4:	cf 93       	push	r28
    1ca6:	00 d0       	rcall	.+0      	; 0x1ca8 <Timer1_init+0x6>
    1ca8:	cd b7       	in	r28, 0x3d	; 61
    1caa:	de b7       	in	r29, 0x3e	; 62
    1cac:	9a 83       	std	Y+2, r25	; 0x02
    1cae:	89 83       	std	Y+1, r24	; 0x01
	/* 1. Set timer1 initial count */
	TCNT1_REG.TwoBytes = Config_Ptr->initial_value;
    1cb0:	ac e4       	ldi	r26, 0x4C	; 76
    1cb2:	b0 e0       	ldi	r27, 0x00	; 0
    1cb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb8:	80 81       	ld	r24, Z
    1cba:	91 81       	ldd	r25, Z+1	; 0x01
    1cbc:	11 96       	adiw	r26, 0x01	; 1
    1cbe:	9c 93       	st	X, r25
    1cc0:	8e 93       	st	-X, r24

	/* 2. Non PWM mode FOC1A=1 and FOC1B=1 */
	TCCR1A_REG.Bits.FOC1A_Bit = 1;
    1cc2:	ef e4       	ldi	r30, 0x4F	; 79
    1cc4:	f0 e0       	ldi	r31, 0x00	; 0
    1cc6:	80 81       	ld	r24, Z
    1cc8:	84 60       	ori	r24, 0x04	; 4
    1cca:	80 83       	st	Z, r24
	TCCR1A_REG.Bits.FOC1B_Bit = 1;
    1ccc:	ef e4       	ldi	r30, 0x4F	; 79
    1cce:	f0 e0       	ldi	r31, 0x00	; 0
    1cd0:	80 81       	ld	r24, Z
    1cd2:	88 60       	ori	r24, 0x08	; 8
    1cd4:	80 83       	st	Z, r24

	/* 3. Set the mode using WGM10 [TCCR1A] , WGM11 [TCCR1A], WGM12[TCCR1B] */
	TCCR1A_REG.Bits.WGM10_Bit =  ((Config_Ptr->mode) & 0x01);
    1cd6:	af e4       	ldi	r26, 0x4F	; 79
    1cd8:	b0 e0       	ldi	r27, 0x00	; 0
    1cda:	e9 81       	ldd	r30, Y+1	; 0x01
    1cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cde:	85 81       	ldd	r24, Z+5	; 0x05
    1ce0:	81 70       	andi	r24, 0x01	; 1
    1ce2:	81 70       	andi	r24, 0x01	; 1
    1ce4:	81 70       	andi	r24, 0x01	; 1
    1ce6:	98 2f       	mov	r25, r24
    1ce8:	91 70       	andi	r25, 0x01	; 1
    1cea:	8c 91       	ld	r24, X
    1cec:	8e 7f       	andi	r24, 0xFE	; 254
    1cee:	89 2b       	or	r24, r25
    1cf0:	8c 93       	st	X, r24
	TCCR1A_REG.Bits.WGM11_Bit =  (((Config_Ptr->mode) & 0x02) >> 1);
    1cf2:	af e4       	ldi	r26, 0x4F	; 79
    1cf4:	b0 e0       	ldi	r27, 0x00	; 0
    1cf6:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cfa:	85 81       	ldd	r24, Z+5	; 0x05
    1cfc:	88 2f       	mov	r24, r24
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	82 70       	andi	r24, 0x02	; 2
    1d02:	90 70       	andi	r25, 0x00	; 0
    1d04:	95 95       	asr	r25
    1d06:	87 95       	ror	r24
    1d08:	81 70       	andi	r24, 0x01	; 1
    1d0a:	81 70       	andi	r24, 0x01	; 1
    1d0c:	98 2f       	mov	r25, r24
    1d0e:	99 0f       	add	r25, r25
    1d10:	8c 91       	ld	r24, X
    1d12:	8d 7f       	andi	r24, 0xFD	; 253
    1d14:	89 2b       	or	r24, r25
    1d16:	8c 93       	st	X, r24
	TCCR1B_REG.Bits.WGM12_Bit =  (((Config_Ptr->mode) & 0x04) >> 2);
    1d18:	ae e4       	ldi	r26, 0x4E	; 78
    1d1a:	b0 e0       	ldi	r27, 0x00	; 0
    1d1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d20:	85 81       	ldd	r24, Z+5	; 0x05
    1d22:	88 2f       	mov	r24, r24
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	84 70       	andi	r24, 0x04	; 4
    1d28:	90 70       	andi	r25, 0x00	; 0
    1d2a:	95 95       	asr	r25
    1d2c:	87 95       	ror	r24
    1d2e:	95 95       	asr	r25
    1d30:	87 95       	ror	r24
    1d32:	81 70       	andi	r24, 0x01	; 1
    1d34:	81 70       	andi	r24, 0x01	; 1
    1d36:	98 2f       	mov	r25, r24
    1d38:	99 0f       	add	r25, r25
    1d3a:	99 0f       	add	r25, r25
    1d3c:	99 0f       	add	r25, r25
    1d3e:	8c 91       	ld	r24, X
    1d40:	87 7f       	andi	r24, 0xF7	; 247
    1d42:	89 2b       	or	r24, r25
    1d44:	8c 93       	st	X, r24

	/* 4. set the Pre-Scalar*/
	TCCR1B_REG.Bits.CS10_Bit = ((Config_Ptr->prescaler) & 0x01);
    1d46:	ae e4       	ldi	r26, 0x4E	; 78
    1d48:	b0 e0       	ldi	r27, 0x00	; 0
    1d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4e:	84 81       	ldd	r24, Z+4	; 0x04
    1d50:	81 70       	andi	r24, 0x01	; 1
    1d52:	81 70       	andi	r24, 0x01	; 1
    1d54:	81 70       	andi	r24, 0x01	; 1
    1d56:	98 2f       	mov	r25, r24
    1d58:	91 70       	andi	r25, 0x01	; 1
    1d5a:	8c 91       	ld	r24, X
    1d5c:	8e 7f       	andi	r24, 0xFE	; 254
    1d5e:	89 2b       	or	r24, r25
    1d60:	8c 93       	st	X, r24
	TCCR1B_REG.Bits.CS11_Bit =  (((Config_Ptr->prescaler) & 0x02) >> 1);
    1d62:	ae e4       	ldi	r26, 0x4E	; 78
    1d64:	b0 e0       	ldi	r27, 0x00	; 0
    1d66:	e9 81       	ldd	r30, Y+1	; 0x01
    1d68:	fa 81       	ldd	r31, Y+2	; 0x02
    1d6a:	84 81       	ldd	r24, Z+4	; 0x04
    1d6c:	88 2f       	mov	r24, r24
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	82 70       	andi	r24, 0x02	; 2
    1d72:	90 70       	andi	r25, 0x00	; 0
    1d74:	95 95       	asr	r25
    1d76:	87 95       	ror	r24
    1d78:	81 70       	andi	r24, 0x01	; 1
    1d7a:	81 70       	andi	r24, 0x01	; 1
    1d7c:	98 2f       	mov	r25, r24
    1d7e:	99 0f       	add	r25, r25
    1d80:	8c 91       	ld	r24, X
    1d82:	8d 7f       	andi	r24, 0xFD	; 253
    1d84:	89 2b       	or	r24, r25
    1d86:	8c 93       	st	X, r24
	TCCR1B_REG.Bits.CS12_Bit =  (((Config_Ptr->prescaler) & 0x04) >> 2);
    1d88:	ae e4       	ldi	r26, 0x4E	; 78
    1d8a:	b0 e0       	ldi	r27, 0x00	; 0
    1d8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d90:	84 81       	ldd	r24, Z+4	; 0x04
    1d92:	88 2f       	mov	r24, r24
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	84 70       	andi	r24, 0x04	; 4
    1d98:	90 70       	andi	r25, 0x00	; 0
    1d9a:	95 95       	asr	r25
    1d9c:	87 95       	ror	r24
    1d9e:	95 95       	asr	r25
    1da0:	87 95       	ror	r24
    1da2:	81 70       	andi	r24, 0x01	; 1
    1da4:	81 70       	andi	r24, 0x01	; 1
    1da6:	98 2f       	mov	r25, r24
    1da8:	99 0f       	add	r25, r25
    1daa:	99 0f       	add	r25, r25
    1dac:	8c 91       	ld	r24, X
    1dae:	8b 7f       	andi	r24, 0xFB	; 251
    1db0:	89 2b       	or	r24, r25
    1db2:	8c 93       	st	X, r24
#endif

#ifdef TIMER1_COMPARE
#if (CTC_CHANNEL == A)
	/* 1. Set the Compare value in channel A if we using compare mode */
	OCR1A_REG.TwoBytes = Config_Ptr->compare_value;
    1db4:	aa e4       	ldi	r26, 0x4A	; 74
    1db6:	b0 e0       	ldi	r27, 0x00	; 0
    1db8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dba:	fa 81       	ldd	r31, Y+2	; 0x02
    1dbc:	82 81       	ldd	r24, Z+2	; 0x02
    1dbe:	93 81       	ldd	r25, Z+3	; 0x03
    1dc0:	11 96       	adiw	r26, 0x01	; 1
    1dc2:	9c 93       	st	X, r25
    1dc4:	8e 93       	st	-X, r24
	/* 2. enable compare interrupt enable*/
	TIMSK_REG.Bits.OCIE1A_Bit= 1;
    1dc6:	e9 e5       	ldi	r30, 0x59	; 89
    1dc8:	f0 e0       	ldi	r31, 0x00	; 0
    1dca:	80 81       	ld	r24, Z
    1dcc:	80 61       	ori	r24, 0x10	; 16
    1dce:	80 83       	st	Z, r24
	OCR1B_REG.TwoBytes = Config_Ptr->compare_value;
	/* 2. enable compare interrupt enable*/
	TIMSK_REG.Bits.OCIE1B_Bit= 1;
#endif
#endif
}
    1dd0:	0f 90       	pop	r0
    1dd2:	0f 90       	pop	r0
    1dd4:	cf 91       	pop	r28
    1dd6:	df 91       	pop	r29
    1dd8:	08 95       	ret

00001dda <Timer1_deInit>:
	 Function to disable the Timer1.
 Inputs: None
 Return: None
 */
void Timer1_deInit(void)
{
    1dda:	df 93       	push	r29
    1ddc:	cf 93       	push	r28
    1dde:	cd b7       	in	r28, 0x3d	; 61
    1de0:	de b7       	in	r29, 0x3e	; 62
	/* Clear Timer1 Registers */
	TCCR1A_REG.Byte = 0;
    1de2:	ef e4       	ldi	r30, 0x4F	; 79
    1de4:	f0 e0       	ldi	r31, 0x00	; 0
    1de6:	10 82       	st	Z, r1
	TCCR1B_REG.Byte = 0;
    1de8:	ee e4       	ldi	r30, 0x4E	; 78
    1dea:	f0 e0       	ldi	r31, 0x00	; 0
    1dec:	10 82       	st	Z, r1
}
    1dee:	cf 91       	pop	r28
    1df0:	df 91       	pop	r29
    1df2:	08 95       	ret

00001df4 <Timer1_setCallBack>:
 Inputs: pointer to Call Back function.
 Return: None
 */

void Timer1_setCallBack(void(*a_ptr)(void))
{
    1df4:	df 93       	push	r29
    1df6:	cf 93       	push	r28
    1df8:	00 d0       	rcall	.+0      	; 0x1dfa <Timer1_setCallBack+0x6>
    1dfa:	cd b7       	in	r28, 0x3d	; 61
    1dfc:	de b7       	in	r29, 0x3e	; 62
    1dfe:	9a 83       	std	Y+2, r25	; 0x02
    1e00:	89 83       	std	Y+1, r24	; 0x01
	/* Save the address of the Call back function in a global variable */
	g_callBackPtr = a_ptr;
    1e02:	89 81       	ldd	r24, Y+1	; 0x01
    1e04:	9a 81       	ldd	r25, Y+2	; 0x02
    1e06:	90 93 7e 01 	sts	0x017E, r25
    1e0a:	80 93 7d 01 	sts	0x017D, r24
}
    1e0e:	0f 90       	pop	r0
    1e10:	0f 90       	pop	r0
    1e12:	cf 91       	pop	r28
    1e14:	df 91       	pop	r29
    1e16:	08 95       	ret

00001e18 <TWI_init>:

/*******************************************************************************
 *                      Functions Definitions                                   *
 *******************************************************************************/
void TWI_init(const TWI_ConfigType * Config_Ptr)
{
    1e18:	0f 93       	push	r16
    1e1a:	1f 93       	push	r17
    1e1c:	df 93       	push	r29
    1e1e:	cf 93       	push	r28
    1e20:	00 d0       	rcall	.+0      	; 0x1e22 <TWI_init+0xa>
    1e22:	cd b7       	in	r28, 0x3d	; 61
    1e24:	de b7       	in	r29, 0x3e	; 62
    1e26:	9a 83       	std	Y+2, r25	; 0x02
    1e28:	89 83       	std	Y+1, r24	; 0x01

	/* calculate the TWBR using zero pre-scaler TWPS=00 and F_CPU, bit rate  */
	TWSR = 0x00;
    1e2a:	e1 e2       	ldi	r30, 0x21	; 33
    1e2c:	f0 e0       	ldi	r31, 0x00	; 0
    1e2e:	10 82       	st	Z, r1
	TWBR = (uint16)(((F_CPU / Config_Ptr->bit_rate )-16) / 8);
    1e30:	00 e2       	ldi	r16, 0x20	; 32
    1e32:	10 e0       	ldi	r17, 0x00	; 0
    1e34:	e9 81       	ldd	r30, Y+1	; 0x01
    1e36:	fa 81       	ldd	r31, Y+2	; 0x02
    1e38:	21 81       	ldd	r18, Z+1	; 0x01
    1e3a:	32 81       	ldd	r19, Z+2	; 0x02
    1e3c:	43 81       	ldd	r20, Z+3	; 0x03
    1e3e:	54 81       	ldd	r21, Z+4	; 0x04
    1e40:	80 e0       	ldi	r24, 0x00	; 0
    1e42:	92 e1       	ldi	r25, 0x12	; 18
    1e44:	aa e7       	ldi	r26, 0x7A	; 122
    1e46:	b0 e0       	ldi	r27, 0x00	; 0
    1e48:	bc 01       	movw	r22, r24
    1e4a:	cd 01       	movw	r24, r26
    1e4c:	0e 94 3e 11 	call	0x227c	; 0x227c <__udivmodsi4>
    1e50:	da 01       	movw	r26, r20
    1e52:	c9 01       	movw	r24, r18
    1e54:	40 97       	sbiw	r24, 0x10	; 16
    1e56:	a1 09       	sbc	r26, r1
    1e58:	b1 09       	sbc	r27, r1
    1e5a:	68 94       	set
    1e5c:	12 f8       	bld	r1, 2
    1e5e:	b6 95       	lsr	r27
    1e60:	a7 95       	ror	r26
    1e62:	97 95       	ror	r25
    1e64:	87 95       	ror	r24
    1e66:	16 94       	lsr	r1
    1e68:	d1 f7       	brne	.-12     	; 0x1e5e <TWI_init+0x46>
    1e6a:	f8 01       	movw	r30, r16
    1e6c:	80 83       	st	Z, r24

	/* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
	       General Call Recognition: Off */
	TWAR = Config_Ptr->address; // my address = 0x01 :)
    1e6e:	a2 e2       	ldi	r26, 0x22	; 34
    1e70:	b0 e0       	ldi	r27, 0x00	; 0
    1e72:	e9 81       	ldd	r30, Y+1	; 0x01
    1e74:	fa 81       	ldd	r31, Y+2	; 0x02
    1e76:	80 81       	ld	r24, Z
    1e78:	8c 93       	st	X, r24

	/* enable the TWI*/
	TWCR = (1<<TWEN);
    1e7a:	e6 e5       	ldi	r30, 0x56	; 86
    1e7c:	f0 e0       	ldi	r31, 0x00	; 0
    1e7e:	84 e0       	ldi	r24, 0x04	; 4
    1e80:	80 83       	st	Z, r24
}
    1e82:	0f 90       	pop	r0
    1e84:	0f 90       	pop	r0
    1e86:	cf 91       	pop	r28
    1e88:	df 91       	pop	r29
    1e8a:	1f 91       	pop	r17
    1e8c:	0f 91       	pop	r16
    1e8e:	08 95       	ret

00001e90 <TWI_start>:

void TWI_start(void)
{
    1e90:	df 93       	push	r29
    1e92:	cf 93       	push	r28
    1e94:	cd b7       	in	r28, 0x3d	; 61
    1e96:	de b7       	in	r29, 0x3e	; 62
    /*
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    1e98:	e6 e5       	ldi	r30, 0x56	; 86
    1e9a:	f0 e0       	ldi	r31, 0x00	; 0
    1e9c:	84 ea       	ldi	r24, 0xA4	; 164
    1e9e:	80 83       	st	Z, r24

    /* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
    while(BIT_IS_CLEAR(TWCR, TWINT));
    1ea0:	e6 e5       	ldi	r30, 0x56	; 86
    1ea2:	f0 e0       	ldi	r31, 0x00	; 0
    1ea4:	80 81       	ld	r24, Z
    1ea6:	88 23       	and	r24, r24
    1ea8:	dc f7       	brge	.-10     	; 0x1ea0 <TWI_start+0x10>
}
    1eaa:	cf 91       	pop	r28
    1eac:	df 91       	pop	r29
    1eae:	08 95       	ret

00001eb0 <TWI_stop>:

void TWI_stop(void)
{
    1eb0:	df 93       	push	r29
    1eb2:	cf 93       	push	r28
    1eb4:	cd b7       	in	r28, 0x3d	; 61
    1eb6:	de b7       	in	r29, 0x3e	; 62
    /*
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
    1eb8:	e6 e5       	ldi	r30, 0x56	; 86
    1eba:	f0 e0       	ldi	r31, 0x00	; 0
    1ebc:	84 e9       	ldi	r24, 0x94	; 148
    1ebe:	80 83       	st	Z, r24
}
    1ec0:	cf 91       	pop	r28
    1ec2:	df 91       	pop	r29
    1ec4:	08 95       	ret

00001ec6 <TWI_writeByte>:

void TWI_writeByte(uint8 data)
{
    1ec6:	df 93       	push	r29
    1ec8:	cf 93       	push	r28
    1eca:	0f 92       	push	r0
    1ecc:	cd b7       	in	r28, 0x3d	; 61
    1ece:	de b7       	in	r29, 0x3e	; 62
    1ed0:	89 83       	std	Y+1, r24	; 0x01
    /* Put data On TWI data Register */
	TWDR = data;
    1ed2:	e3 e2       	ldi	r30, 0x23	; 35
    1ed4:	f0 e0       	ldi	r31, 0x00	; 0
    1ed6:	89 81       	ldd	r24, Y+1	; 0x01
    1ed8:	80 83       	st	Z, r24

    /*
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWEN);
    1eda:	e6 e5       	ldi	r30, 0x56	; 86
    1edc:	f0 e0       	ldi	r31, 0x00	; 0
    1ede:	84 e8       	ldi	r24, 0x84	; 132
    1ee0:	80 83       	st	Z, r24

    /* Wait for TWINT flag set in TWCR Register(data is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1ee2:	e6 e5       	ldi	r30, 0x56	; 86
    1ee4:	f0 e0       	ldi	r31, 0x00	; 0
    1ee6:	80 81       	ld	r24, Z
    1ee8:	88 23       	and	r24, r24
    1eea:	dc f7       	brge	.-10     	; 0x1ee2 <TWI_writeByte+0x1c>
}
    1eec:	0f 90       	pop	r0
    1eee:	cf 91       	pop	r28
    1ef0:	df 91       	pop	r29
    1ef2:	08 95       	ret

00001ef4 <TWI_readByteWithACK>:

uint8 TWI_readByteWithACK(void)
{
    1ef4:	df 93       	push	r29
    1ef6:	cf 93       	push	r28
    1ef8:	cd b7       	in	r28, 0x3d	; 61
    1efa:	de b7       	in	r29, 0x3e	; 62
    /*
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    1efc:	e6 e5       	ldi	r30, 0x56	; 86
    1efe:	f0 e0       	ldi	r31, 0x00	; 0
    1f00:	84 ec       	ldi	r24, 0xC4	; 196
    1f02:	80 83       	st	Z, r24

    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
    1f04:	e6 e5       	ldi	r30, 0x56	; 86
    1f06:	f0 e0       	ldi	r31, 0x00	; 0
    1f08:	80 81       	ld	r24, Z
    1f0a:	88 23       	and	r24, r24
    1f0c:	dc f7       	brge	.-10     	; 0x1f04 <TWI_readByteWithACK+0x10>

    /* Return the Data */
    return TWCR;
    1f0e:	e6 e5       	ldi	r30, 0x56	; 86
    1f10:	f0 e0       	ldi	r31, 0x00	; 0
    1f12:	80 81       	ld	r24, Z
}
    1f14:	cf 91       	pop	r28
    1f16:	df 91       	pop	r29
    1f18:	08 95       	ret

00001f1a <TWI_readByteWithNACK>:

uint8 TWI_readByteWithNACK(void)
{
    1f1a:	df 93       	push	r29
    1f1c:	cf 93       	push	r28
    1f1e:	cd b7       	in	r28, 0x3d	; 61
    1f20:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
    TWCR = (1 << TWINT) | (1 << TWEN);
    1f22:	e6 e5       	ldi	r30, 0x56	; 86
    1f24:	f0 e0       	ldi	r31, 0x00	; 0
    1f26:	84 e8       	ldi	r24, 0x84	; 132
    1f28:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR, TWINT));
    1f2a:	e6 e5       	ldi	r30, 0x56	; 86
    1f2c:	f0 e0       	ldi	r31, 0x00	; 0
    1f2e:	80 81       	ld	r24, Z
    1f30:	88 23       	and	r24, r24
    1f32:	dc f7       	brge	.-10     	; 0x1f2a <TWI_readByteWithNACK+0x10>
    /* Read Data */
    return TWDR;
    1f34:	e3 e2       	ldi	r30, 0x23	; 35
    1f36:	f0 e0       	ldi	r31, 0x00	; 0
    1f38:	80 81       	ld	r24, Z
}
    1f3a:	cf 91       	pop	r28
    1f3c:	df 91       	pop	r29
    1f3e:	08 95       	ret

00001f40 <TWI_getStatus>:

uint8 TWI_getStatus(void)
{
    1f40:	df 93       	push	r29
    1f42:	cf 93       	push	r28
    1f44:	0f 92       	push	r0
    1f46:	cd b7       	in	r28, 0x3d	; 61
    1f48:	de b7       	in	r29, 0x3e	; 62
    uint8 status;
    /* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
    status = TWSR & 0xF8;		/* 1111 1000*/
    1f4a:	e1 e2       	ldi	r30, 0x21	; 33
    1f4c:	f0 e0       	ldi	r31, 0x00	; 0
    1f4e:	80 81       	ld	r24, Z
    1f50:	88 7f       	andi	r24, 0xF8	; 248
    1f52:	89 83       	std	Y+1, r24	; 0x01

    return status;
    1f54:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f56:	0f 90       	pop	r0
    1f58:	cf 91       	pop	r28
    1f5a:	df 91       	pop	r29
    1f5c:	08 95       	ret

00001f5e <UART_init>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
    1f5e:	df 93       	push	r29
    1f60:	cf 93       	push	r28
    1f62:	00 d0       	rcall	.+0      	; 0x1f64 <UART_init+0x6>
    1f64:	00 d0       	rcall	.+0      	; 0x1f66 <UART_init+0x8>
    1f66:	cd b7       	in	r28, 0x3d	; 61
    1f68:	de b7       	in	r29, 0x3e	; 62
    1f6a:	9c 83       	std	Y+4, r25	; 0x04
    1f6c:	8b 83       	std	Y+3, r24	; 0x03
	uint16 ubrr_value = 0;
    1f6e:	1a 82       	std	Y+2, r1	; 0x02
    1f70:	19 82       	std	Y+1, r1	; 0x01

	/************************** UCSRA Description ***************************/
	/* set the speed mode to the register whether it is normal or double speed */
	UART_UCSRA_REG.Bits.U2X_Bit = Config_Ptr->speed_mode;
    1f72:	ab e2       	ldi	r26, 0x2B	; 43
    1f74:	b0 e0       	ldi	r27, 0x00	; 0
    1f76:	eb 81       	ldd	r30, Y+3	; 0x03
    1f78:	fc 81       	ldd	r31, Y+4	; 0x04
    1f7a:	80 85       	ldd	r24, Z+8	; 0x08
    1f7c:	81 70       	andi	r24, 0x01	; 1
    1f7e:	81 70       	andi	r24, 0x01	; 1
    1f80:	98 2f       	mov	r25, r24
    1f82:	99 0f       	add	r25, r25
    1f84:	8c 91       	ld	r24, X
    1f86:	8d 7f       	andi	r24, 0xFD	; 253
    1f88:	89 2b       	or	r24, r25
    1f8a:	8c 93       	st	X, r24


	/************************** UCSRB Description ***************************/
	/* Enable Transmitter & receiver*/
	UART_UCSRB_REG.Bits.RXEN_Bit = 1;
    1f8c:	ea e2       	ldi	r30, 0x2A	; 42
    1f8e:	f0 e0       	ldi	r31, 0x00	; 0
    1f90:	80 81       	ld	r24, Z
    1f92:	80 61       	ori	r24, 0x10	; 16
    1f94:	80 83       	st	Z, r24
	UART_UCSRB_REG.Bits.TXEN_Bit = 1;
    1f96:	ea e2       	ldi	r30, 0x2A	; 42
    1f98:	f0 e0       	ldi	r31, 0x00	; 0
    1f9a:	80 81       	ld	r24, Z
    1f9c:	88 60       	ori	r24, 0x08	; 8
    1f9e:	80 83       	st	Z, r24

	/* Set the third bits of the character size into the register UCSRC [UCSZ2] */
	UART_UCSRB_REG.Bits.UCSZ2_Bit = (((Config_Ptr->bit_data) & 0x04) >> 2);
    1fa0:	aa e2       	ldi	r26, 0x2A	; 42
    1fa2:	b0 e0       	ldi	r27, 0x00	; 0
    1fa4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa8:	80 81       	ld	r24, Z
    1faa:	88 2f       	mov	r24, r24
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	84 70       	andi	r24, 0x04	; 4
    1fb0:	90 70       	andi	r25, 0x00	; 0
    1fb2:	95 95       	asr	r25
    1fb4:	87 95       	ror	r24
    1fb6:	95 95       	asr	r25
    1fb8:	87 95       	ror	r24
    1fba:	81 70       	andi	r24, 0x01	; 1
    1fbc:	81 70       	andi	r24, 0x01	; 1
    1fbe:	98 2f       	mov	r25, r24
    1fc0:	99 0f       	add	r25, r25
    1fc2:	99 0f       	add	r25, r25
    1fc4:	8c 91       	ld	r24, X
    1fc6:	8b 7f       	andi	r24, 0xFB	; 251
    1fc8:	89 2b       	or	r24, r25
    1fca:	8c 93       	st	X, r24


	/************************** UCSRC Description ***************************/
	/* The URSEL must be one when writing the UCSRC */
	UART_UCSRC_REG.Bits.URSEL_Bit = 1;
    1fcc:	e0 e4       	ldi	r30, 0x40	; 64
    1fce:	f0 e0       	ldi	r31, 0x00	; 0
    1fd0:	80 81       	ld	r24, Z
    1fd2:	80 68       	ori	r24, 0x80	; 128
    1fd4:	80 83       	st	Z, r24

	/* set the Select mode to the register whether it is synchronous or asynchronous */
	UART_UCSRC_REG.Bits.UMSEL_Bit = Config_Ptr->select_mode;
    1fd6:	a0 e4       	ldi	r26, 0x40	; 64
    1fd8:	b0 e0       	ldi	r27, 0x00	; 0
    1fda:	eb 81       	ldd	r30, Y+3	; 0x03
    1fdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1fde:	87 81       	ldd	r24, Z+7	; 0x07
    1fe0:	81 70       	andi	r24, 0x01	; 1
    1fe2:	81 70       	andi	r24, 0x01	; 1
    1fe4:	98 2f       	mov	r25, r24
    1fe6:	92 95       	swap	r25
    1fe8:	99 0f       	add	r25, r25
    1fea:	99 0f       	add	r25, r25
    1fec:	90 7c       	andi	r25, 0xC0	; 192
    1fee:	8c 91       	ld	r24, X
    1ff0:	8f 7b       	andi	r24, 0xBF	; 191
    1ff2:	89 2b       	or	r24, r25
    1ff4:	8c 93       	st	X, r24

	/* set the Parity mode to the register*/
	UART_UCSRC_REG.Bits.UPM0_Bit = ((Config_Ptr->parity) & 0x01);
    1ff6:	a0 e4       	ldi	r26, 0x40	; 64
    1ff8:	b0 e0       	ldi	r27, 0x00	; 0
    1ffa:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ffe:	81 81       	ldd	r24, Z+1	; 0x01
    2000:	81 70       	andi	r24, 0x01	; 1
    2002:	81 70       	andi	r24, 0x01	; 1
    2004:	81 70       	andi	r24, 0x01	; 1
    2006:	81 70       	andi	r24, 0x01	; 1
    2008:	98 2f       	mov	r25, r24
    200a:	92 95       	swap	r25
    200c:	90 7f       	andi	r25, 0xF0	; 240
    200e:	8c 91       	ld	r24, X
    2010:	8f 7e       	andi	r24, 0xEF	; 239
    2012:	89 2b       	or	r24, r25
    2014:	8c 93       	st	X, r24
	UART_UCSRC_REG.Bits.UPM1_Bit = (((Config_Ptr->parity) & 0x02) >> 1);
    2016:	a0 e4       	ldi	r26, 0x40	; 64
    2018:	b0 e0       	ldi	r27, 0x00	; 0
    201a:	eb 81       	ldd	r30, Y+3	; 0x03
    201c:	fc 81       	ldd	r31, Y+4	; 0x04
    201e:	81 81       	ldd	r24, Z+1	; 0x01
    2020:	88 2f       	mov	r24, r24
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	82 70       	andi	r24, 0x02	; 2
    2026:	90 70       	andi	r25, 0x00	; 0
    2028:	95 95       	asr	r25
    202a:	87 95       	ror	r24
    202c:	81 70       	andi	r24, 0x01	; 1
    202e:	81 70       	andi	r24, 0x01	; 1
    2030:	98 2f       	mov	r25, r24
    2032:	92 95       	swap	r25
    2034:	99 0f       	add	r25, r25
    2036:	90 7e       	andi	r25, 0xE0	; 224
    2038:	8c 91       	ld	r24, X
    203a:	8f 7d       	andi	r24, 0xDF	; 223
    203c:	89 2b       	or	r24, r25
    203e:	8c 93       	st	X, r24

	/* set the Stop Bit Select to the register*/
	UART_UCSRC_REG.Bits.USBS_Bit = Config_Ptr->stop_bit;
    2040:	a0 e4       	ldi	r26, 0x40	; 64
    2042:	b0 e0       	ldi	r27, 0x00	; 0
    2044:	eb 81       	ldd	r30, Y+3	; 0x03
    2046:	fc 81       	ldd	r31, Y+4	; 0x04
    2048:	82 81       	ldd	r24, Z+2	; 0x02
    204a:	81 70       	andi	r24, 0x01	; 1
    204c:	81 70       	andi	r24, 0x01	; 1
    204e:	98 2f       	mov	r25, r24
    2050:	99 0f       	add	r25, r25
    2052:	99 0f       	add	r25, r25
    2054:	99 0f       	add	r25, r25
    2056:	8c 91       	ld	r24, X
    2058:	87 7f       	andi	r24, 0xF7	; 247
    205a:	89 2b       	or	r24, r25
    205c:	8c 93       	st	X, r24

	/* Set the 2 bits of the character size into the register UCSRC [UCSZ0 UCSZ1]
	   - insert the required data bits in the second 2 bits (UCSZ1 , UCSZ0)of UCSRC Register
	 */
	UART_UCSRC_REG.Bits.USCZ0_Bit = ((Config_Ptr->bit_data) & 0x01);
    205e:	a0 e4       	ldi	r26, 0x40	; 64
    2060:	b0 e0       	ldi	r27, 0x00	; 0
    2062:	eb 81       	ldd	r30, Y+3	; 0x03
    2064:	fc 81       	ldd	r31, Y+4	; 0x04
    2066:	80 81       	ld	r24, Z
    2068:	81 70       	andi	r24, 0x01	; 1
    206a:	81 70       	andi	r24, 0x01	; 1
    206c:	81 70       	andi	r24, 0x01	; 1
    206e:	81 70       	andi	r24, 0x01	; 1
    2070:	98 2f       	mov	r25, r24
    2072:	99 0f       	add	r25, r25
    2074:	8c 91       	ld	r24, X
    2076:	8d 7f       	andi	r24, 0xFD	; 253
    2078:	89 2b       	or	r24, r25
    207a:	8c 93       	st	X, r24
	UART_UCSRC_REG.Bits.USCZ1_Bit = (((Config_Ptr->bit_data) & 0x02) >> 1);
    207c:	a0 e4       	ldi	r26, 0x40	; 64
    207e:	b0 e0       	ldi	r27, 0x00	; 0
    2080:	eb 81       	ldd	r30, Y+3	; 0x03
    2082:	fc 81       	ldd	r31, Y+4	; 0x04
    2084:	80 81       	ld	r24, Z
    2086:	88 2f       	mov	r24, r24
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	82 70       	andi	r24, 0x02	; 2
    208c:	90 70       	andi	r25, 0x00	; 0
    208e:	95 95       	asr	r25
    2090:	87 95       	ror	r24
    2092:	81 70       	andi	r24, 0x01	; 1
    2094:	81 70       	andi	r24, 0x01	; 1
    2096:	98 2f       	mov	r25, r24
    2098:	99 0f       	add	r25, r25
    209a:	99 0f       	add	r25, r25
    209c:	8c 91       	ld	r24, X
    209e:	8b 7f       	andi	r24, 0xFB	; 251
    20a0:	89 2b       	or	r24, r25
    20a2:	8c 93       	st	X, r24


	/* Calculate the UBRR register value */
#if (UART_SPEED_MODE == ASYNCHRONOUS_DOUBLE_SPEED_MODE)
	ubrr_value = (uint16)(((F_CPU / (Config_Ptr->baud_rate * 8UL))) - 1);
    20a4:	eb 81       	ldd	r30, Y+3	; 0x03
    20a6:	fc 81       	ldd	r31, Y+4	; 0x04
    20a8:	83 81       	ldd	r24, Z+3	; 0x03
    20aa:	94 81       	ldd	r25, Z+4	; 0x04
    20ac:	a5 81       	ldd	r26, Z+5	; 0x05
    20ae:	b6 81       	ldd	r27, Z+6	; 0x06
    20b0:	88 0f       	add	r24, r24
    20b2:	99 1f       	adc	r25, r25
    20b4:	aa 1f       	adc	r26, r26
    20b6:	bb 1f       	adc	r27, r27
    20b8:	88 0f       	add	r24, r24
    20ba:	99 1f       	adc	r25, r25
    20bc:	aa 1f       	adc	r26, r26
    20be:	bb 1f       	adc	r27, r27
    20c0:	88 0f       	add	r24, r24
    20c2:	99 1f       	adc	r25, r25
    20c4:	aa 1f       	adc	r26, r26
    20c6:	bb 1f       	adc	r27, r27
    20c8:	9c 01       	movw	r18, r24
    20ca:	ad 01       	movw	r20, r26
    20cc:	80 e0       	ldi	r24, 0x00	; 0
    20ce:	92 e1       	ldi	r25, 0x12	; 18
    20d0:	aa e7       	ldi	r26, 0x7A	; 122
    20d2:	b0 e0       	ldi	r27, 0x00	; 0
    20d4:	bc 01       	movw	r22, r24
    20d6:	cd 01       	movw	r24, r26
    20d8:	0e 94 3e 11 	call	0x227c	; 0x227c <__udivmodsi4>
    20dc:	da 01       	movw	r26, r20
    20de:	c9 01       	movw	r24, r18
    20e0:	01 97       	sbiw	r24, 0x01	; 1
    20e2:	9a 83       	std	Y+2, r25	; 0x02
    20e4:	89 83       	std	Y+1, r24	; 0x01
	/* Invalid speed setting, return */
	return;
#endif

	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UART_UBRRH_REG.Byte = ubrr_value>>8;
    20e6:	e0 e4       	ldi	r30, 0x40	; 64
    20e8:	f0 e0       	ldi	r31, 0x00	; 0
    20ea:	89 81       	ldd	r24, Y+1	; 0x01
    20ec:	9a 81       	ldd	r25, Y+2	; 0x02
    20ee:	89 2f       	mov	r24, r25
    20f0:	99 27       	eor	r25, r25
    20f2:	80 83       	st	Z, r24
	UART_UBRRL_REG.Byte = ubrr_value;
    20f4:	e9 e2       	ldi	r30, 0x29	; 41
    20f6:	f0 e0       	ldi	r31, 0x00	; 0
    20f8:	89 81       	ldd	r24, Y+1	; 0x01
    20fa:	80 83       	st	Z, r24
}
    20fc:	0f 90       	pop	r0
    20fe:	0f 90       	pop	r0
    2100:	0f 90       	pop	r0
    2102:	0f 90       	pop	r0
    2104:	cf 91       	pop	r28
    2106:	df 91       	pop	r29
    2108:	08 95       	ret

0000210a <UART_sendByte>:
/*
 * Description :
 * Functional responsible for send byte to another UART device.
 */
void UART_sendByte(const uint8 data)
{
    210a:	df 93       	push	r29
    210c:	cf 93       	push	r28
    210e:	0f 92       	push	r0
    2110:	cd b7       	in	r28, 0x3d	; 61
    2112:	de b7       	in	r29, 0x3e	; 62
    2114:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * UDRE flag is set when the Tx buffer (UDR) is empty and ready for
	 * transmitting a new byte so wait until this flag is set to one
	 */
	while(BIT_IS_CLEAR(UART_UCSRA_REG.Byte,UART_UCSRA_REG.Bits.UDRE_Bit)){}
    2116:	eb e2       	ldi	r30, 0x2B	; 43
    2118:	f0 e0       	ldi	r31, 0x00	; 0
    211a:	80 81       	ld	r24, Z
    211c:	28 2f       	mov	r18, r24
    211e:	30 e0       	ldi	r19, 0x00	; 0
    2120:	eb e2       	ldi	r30, 0x2B	; 43
    2122:	f0 e0       	ldi	r31, 0x00	; 0
    2124:	80 81       	ld	r24, Z
    2126:	82 95       	swap	r24
    2128:	86 95       	lsr	r24
    212a:	87 70       	andi	r24, 0x07	; 7
    212c:	81 70       	andi	r24, 0x01	; 1
    212e:	88 2f       	mov	r24, r24
    2130:	90 e0       	ldi	r25, 0x00	; 0
    2132:	a9 01       	movw	r20, r18
    2134:	02 c0       	rjmp	.+4      	; 0x213a <UART_sendByte+0x30>
    2136:	55 95       	asr	r21
    2138:	47 95       	ror	r20
    213a:	8a 95       	dec	r24
    213c:	e2 f7       	brpl	.-8      	; 0x2136 <UART_sendByte+0x2c>
    213e:	ca 01       	movw	r24, r20
    2140:	81 70       	andi	r24, 0x01	; 1
    2142:	90 70       	andi	r25, 0x00	; 0
    2144:	00 97       	sbiw	r24, 0x00	; 0
    2146:	39 f3       	breq	.-50     	; 0x2116 <UART_sendByte+0xc>

	/*
	 * Put the required data in the UDR register and it also clear the UDRE flag as
	 * the UDR register is not empty now
	 */
	UART_UDR_REG.TwoBytes = data;
    2148:	ec e2       	ldi	r30, 0x2C	; 44
    214a:	f0 e0       	ldi	r31, 0x00	; 0
    214c:	89 81       	ldd	r24, Y+1	; 0x01
    214e:	88 2f       	mov	r24, r24
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	91 83       	std	Z+1, r25	; 0x01
    2154:	80 83       	st	Z, r24
	/************************* Another Method *************************
	UDR = data;
	while(BIT_IS_CLEAR(UCSRA,TXC)){} // Wait until the transmission is complete TXC = 1
	SET_BIT(UCSRA,TXC); // Clear the TXC flag
	*******************************************************************/
}
    2156:	0f 90       	pop	r0
    2158:	cf 91       	pop	r28
    215a:	df 91       	pop	r29
    215c:	08 95       	ret

0000215e <UART_recieveByte>:
/*
 * Description :
 * Functional responsible for receive byte from another UART device.
 */
uint8 UART_recieveByte(void)
{
    215e:	df 93       	push	r29
    2160:	cf 93       	push	r28
    2162:	cd b7       	in	r28, 0x3d	; 61
    2164:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this flag is set to one */
	while(BIT_IS_CLEAR(UART_UCSRA_REG.Byte,UART_UCSRA_REG.Bits.RXC_Bit)){}
    2166:	eb e2       	ldi	r30, 0x2B	; 43
    2168:	f0 e0       	ldi	r31, 0x00	; 0
    216a:	80 81       	ld	r24, Z
    216c:	28 2f       	mov	r18, r24
    216e:	30 e0       	ldi	r19, 0x00	; 0
    2170:	eb e2       	ldi	r30, 0x2B	; 43
    2172:	f0 e0       	ldi	r31, 0x00	; 0
    2174:	80 81       	ld	r24, Z
    2176:	88 1f       	adc	r24, r24
    2178:	88 27       	eor	r24, r24
    217a:	88 1f       	adc	r24, r24
    217c:	88 2f       	mov	r24, r24
    217e:	90 e0       	ldi	r25, 0x00	; 0
    2180:	a9 01       	movw	r20, r18
    2182:	02 c0       	rjmp	.+4      	; 0x2188 <UART_recieveByte+0x2a>
    2184:	55 95       	asr	r21
    2186:	47 95       	ror	r20
    2188:	8a 95       	dec	r24
    218a:	e2 f7       	brpl	.-8      	; 0x2184 <UART_recieveByte+0x26>
    218c:	ca 01       	movw	r24, r20
    218e:	81 70       	andi	r24, 0x01	; 1
    2190:	90 70       	andi	r25, 0x00	; 0
    2192:	00 97       	sbiw	r24, 0x00	; 0
    2194:	41 f3       	breq	.-48     	; 0x2166 <UART_recieveByte+0x8>

	/*
	 * Read the received data from the Rx buffer (UDR)
	 * The RXC flag will be cleared after read the data
	 */
    return (uint8)UART_UDR_REG.TwoBytes;
    2196:	ec e2       	ldi	r30, 0x2C	; 44
    2198:	f0 e0       	ldi	r31, 0x00	; 0
    219a:	80 81       	ld	r24, Z
    219c:	91 81       	ldd	r25, Z+1	; 0x01
}
    219e:	cf 91       	pop	r28
    21a0:	df 91       	pop	r29
    21a2:	08 95       	ret

000021a4 <UART_sendString>:
/*
 * Description :
 * Send the required string through UART to the other UART device.
 */
void UART_sendString(const uint8 *Str)
{
    21a4:	df 93       	push	r29
    21a6:	cf 93       	push	r28
    21a8:	00 d0       	rcall	.+0      	; 0x21aa <UART_sendString+0x6>
    21aa:	0f 92       	push	r0
    21ac:	cd b7       	in	r28, 0x3d	; 61
    21ae:	de b7       	in	r29, 0x3e	; 62
    21b0:	9b 83       	std	Y+3, r25	; 0x03
    21b2:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    21b4:	19 82       	std	Y+1, r1	; 0x01
    21b6:	0e c0       	rjmp	.+28     	; 0x21d4 <UART_sendString+0x30>

	/* Send the whole string */
	while(Str[i] != '\0')
	{
		UART_sendByte(Str[i]);
    21b8:	89 81       	ldd	r24, Y+1	; 0x01
    21ba:	28 2f       	mov	r18, r24
    21bc:	30 e0       	ldi	r19, 0x00	; 0
    21be:	8a 81       	ldd	r24, Y+2	; 0x02
    21c0:	9b 81       	ldd	r25, Y+3	; 0x03
    21c2:	fc 01       	movw	r30, r24
    21c4:	e2 0f       	add	r30, r18
    21c6:	f3 1f       	adc	r31, r19
    21c8:	80 81       	ld	r24, Z
    21ca:	0e 94 85 10 	call	0x210a	; 0x210a <UART_sendByte>
		i++;
    21ce:	89 81       	ldd	r24, Y+1	; 0x01
    21d0:	8f 5f       	subi	r24, 0xFF	; 255
    21d2:	89 83       	std	Y+1, r24	; 0x01
void UART_sendString(const uint8 *Str)
{
	uint8 i = 0;

	/* Send the whole string */
	while(Str[i] != '\0')
    21d4:	89 81       	ldd	r24, Y+1	; 0x01
    21d6:	28 2f       	mov	r18, r24
    21d8:	30 e0       	ldi	r19, 0x00	; 0
    21da:	8a 81       	ldd	r24, Y+2	; 0x02
    21dc:	9b 81       	ldd	r25, Y+3	; 0x03
    21de:	fc 01       	movw	r30, r24
    21e0:	e2 0f       	add	r30, r18
    21e2:	f3 1f       	adc	r31, r19
    21e4:	80 81       	ld	r24, Z
    21e6:	88 23       	and	r24, r24
    21e8:	39 f7       	brne	.-50     	; 0x21b8 <UART_sendString+0x14>
	{
		UART_sendByte(*Str);
		Str++;
	}
	*******************************************************************/
}
    21ea:	0f 90       	pop	r0
    21ec:	0f 90       	pop	r0
    21ee:	0f 90       	pop	r0
    21f0:	cf 91       	pop	r28
    21f2:	df 91       	pop	r29
    21f4:	08 95       	ret

000021f6 <UART_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through UART from the other UART device.
 */
void UART_receiveString(uint8 *Str)
{
    21f6:	0f 93       	push	r16
    21f8:	1f 93       	push	r17
    21fa:	df 93       	push	r29
    21fc:	cf 93       	push	r28
    21fe:	00 d0       	rcall	.+0      	; 0x2200 <UART_receiveString+0xa>
    2200:	0f 92       	push	r0
    2202:	cd b7       	in	r28, 0x3d	; 61
    2204:	de b7       	in	r29, 0x3e	; 62
    2206:	9b 83       	std	Y+3, r25	; 0x03
    2208:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    220a:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_recieveByte();
    220c:	89 81       	ldd	r24, Y+1	; 0x01
    220e:	28 2f       	mov	r18, r24
    2210:	30 e0       	ldi	r19, 0x00	; 0
    2212:	8a 81       	ldd	r24, Y+2	; 0x02
    2214:	9b 81       	ldd	r25, Y+3	; 0x03
    2216:	8c 01       	movw	r16, r24
    2218:	02 0f       	add	r16, r18
    221a:	13 1f       	adc	r17, r19
    221c:	0e 94 af 10 	call	0x215e	; 0x215e <UART_recieveByte>
    2220:	f8 01       	movw	r30, r16
    2222:	80 83       	st	Z, r24
    2224:	0f c0       	rjmp	.+30     	; 0x2244 <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
	{
		i++;
    2226:	89 81       	ldd	r24, Y+1	; 0x01
    2228:	8f 5f       	subi	r24, 0xFF	; 255
    222a:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_recieveByte();
    222c:	89 81       	ldd	r24, Y+1	; 0x01
    222e:	28 2f       	mov	r18, r24
    2230:	30 e0       	ldi	r19, 0x00	; 0
    2232:	8a 81       	ldd	r24, Y+2	; 0x02
    2234:	9b 81       	ldd	r25, Y+3	; 0x03
    2236:	8c 01       	movw	r16, r24
    2238:	02 0f       	add	r16, r18
    223a:	13 1f       	adc	r17, r19
    223c:	0e 94 af 10 	call	0x215e	; 0x215e <UART_recieveByte>
    2240:	f8 01       	movw	r30, r16
    2242:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_recieveByte();

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
    2244:	89 81       	ldd	r24, Y+1	; 0x01
    2246:	28 2f       	mov	r18, r24
    2248:	30 e0       	ldi	r19, 0x00	; 0
    224a:	8a 81       	ldd	r24, Y+2	; 0x02
    224c:	9b 81       	ldd	r25, Y+3	; 0x03
    224e:	fc 01       	movw	r30, r24
    2250:	e2 0f       	add	r30, r18
    2252:	f3 1f       	adc	r31, r19
    2254:	80 81       	ld	r24, Z
    2256:	83 32       	cpi	r24, 0x23	; 35
    2258:	31 f7       	brne	.-52     	; 0x2226 <UART_receiveString+0x30>
		i++;
		Str[i] = UART_recieveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
    225a:	89 81       	ldd	r24, Y+1	; 0x01
    225c:	28 2f       	mov	r18, r24
    225e:	30 e0       	ldi	r19, 0x00	; 0
    2260:	8a 81       	ldd	r24, Y+2	; 0x02
    2262:	9b 81       	ldd	r25, Y+3	; 0x03
    2264:	fc 01       	movw	r30, r24
    2266:	e2 0f       	add	r30, r18
    2268:	f3 1f       	adc	r31, r19
    226a:	10 82       	st	Z, r1

}
    226c:	0f 90       	pop	r0
    226e:	0f 90       	pop	r0
    2270:	0f 90       	pop	r0
    2272:	cf 91       	pop	r28
    2274:	df 91       	pop	r29
    2276:	1f 91       	pop	r17
    2278:	0f 91       	pop	r16
    227a:	08 95       	ret

0000227c <__udivmodsi4>:
    227c:	a1 e2       	ldi	r26, 0x21	; 33
    227e:	1a 2e       	mov	r1, r26
    2280:	aa 1b       	sub	r26, r26
    2282:	bb 1b       	sub	r27, r27
    2284:	fd 01       	movw	r30, r26
    2286:	0d c0       	rjmp	.+26     	; 0x22a2 <__udivmodsi4_ep>

00002288 <__udivmodsi4_loop>:
    2288:	aa 1f       	adc	r26, r26
    228a:	bb 1f       	adc	r27, r27
    228c:	ee 1f       	adc	r30, r30
    228e:	ff 1f       	adc	r31, r31
    2290:	a2 17       	cp	r26, r18
    2292:	b3 07       	cpc	r27, r19
    2294:	e4 07       	cpc	r30, r20
    2296:	f5 07       	cpc	r31, r21
    2298:	20 f0       	brcs	.+8      	; 0x22a2 <__udivmodsi4_ep>
    229a:	a2 1b       	sub	r26, r18
    229c:	b3 0b       	sbc	r27, r19
    229e:	e4 0b       	sbc	r30, r20
    22a0:	f5 0b       	sbc	r31, r21

000022a2 <__udivmodsi4_ep>:
    22a2:	66 1f       	adc	r22, r22
    22a4:	77 1f       	adc	r23, r23
    22a6:	88 1f       	adc	r24, r24
    22a8:	99 1f       	adc	r25, r25
    22aa:	1a 94       	dec	r1
    22ac:	69 f7       	brne	.-38     	; 0x2288 <__udivmodsi4_loop>
    22ae:	60 95       	com	r22
    22b0:	70 95       	com	r23
    22b2:	80 95       	com	r24
    22b4:	90 95       	com	r25
    22b6:	9b 01       	movw	r18, r22
    22b8:	ac 01       	movw	r20, r24
    22ba:	bd 01       	movw	r22, r26
    22bc:	cf 01       	movw	r24, r30
    22be:	08 95       	ret

000022c0 <__prologue_saves__>:
    22c0:	2f 92       	push	r2
    22c2:	3f 92       	push	r3
    22c4:	4f 92       	push	r4
    22c6:	5f 92       	push	r5
    22c8:	6f 92       	push	r6
    22ca:	7f 92       	push	r7
    22cc:	8f 92       	push	r8
    22ce:	9f 92       	push	r9
    22d0:	af 92       	push	r10
    22d2:	bf 92       	push	r11
    22d4:	cf 92       	push	r12
    22d6:	df 92       	push	r13
    22d8:	ef 92       	push	r14
    22da:	ff 92       	push	r15
    22dc:	0f 93       	push	r16
    22de:	1f 93       	push	r17
    22e0:	cf 93       	push	r28
    22e2:	df 93       	push	r29
    22e4:	cd b7       	in	r28, 0x3d	; 61
    22e6:	de b7       	in	r29, 0x3e	; 62
    22e8:	ca 1b       	sub	r28, r26
    22ea:	db 0b       	sbc	r29, r27
    22ec:	0f b6       	in	r0, 0x3f	; 63
    22ee:	f8 94       	cli
    22f0:	de bf       	out	0x3e, r29	; 62
    22f2:	0f be       	out	0x3f, r0	; 63
    22f4:	cd bf       	out	0x3d, r28	; 61
    22f6:	09 94       	ijmp

000022f8 <__epilogue_restores__>:
    22f8:	2a 88       	ldd	r2, Y+18	; 0x12
    22fa:	39 88       	ldd	r3, Y+17	; 0x11
    22fc:	48 88       	ldd	r4, Y+16	; 0x10
    22fe:	5f 84       	ldd	r5, Y+15	; 0x0f
    2300:	6e 84       	ldd	r6, Y+14	; 0x0e
    2302:	7d 84       	ldd	r7, Y+13	; 0x0d
    2304:	8c 84       	ldd	r8, Y+12	; 0x0c
    2306:	9b 84       	ldd	r9, Y+11	; 0x0b
    2308:	aa 84       	ldd	r10, Y+10	; 0x0a
    230a:	b9 84       	ldd	r11, Y+9	; 0x09
    230c:	c8 84       	ldd	r12, Y+8	; 0x08
    230e:	df 80       	ldd	r13, Y+7	; 0x07
    2310:	ee 80       	ldd	r14, Y+6	; 0x06
    2312:	fd 80       	ldd	r15, Y+5	; 0x05
    2314:	0c 81       	ldd	r16, Y+4	; 0x04
    2316:	1b 81       	ldd	r17, Y+3	; 0x03
    2318:	aa 81       	ldd	r26, Y+2	; 0x02
    231a:	b9 81       	ldd	r27, Y+1	; 0x01
    231c:	ce 0f       	add	r28, r30
    231e:	d1 1d       	adc	r29, r1
    2320:	0f b6       	in	r0, 0x3f	; 63
    2322:	f8 94       	cli
    2324:	de bf       	out	0x3e, r29	; 62
    2326:	0f be       	out	0x3f, r0	; 63
    2328:	cd bf       	out	0x3d, r28	; 61
    232a:	ed 01       	movw	r28, r26
    232c:	08 95       	ret

0000232e <_exit>:
    232e:	f8 94       	cli

00002330 <__stop_program>:
    2330:	ff cf       	rjmp	.-2      	; 0x2330 <__stop_program>
